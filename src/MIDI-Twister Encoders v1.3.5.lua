-- MIDI Remotes Installer - MidiFighter Twister
-- v1.3.5

-- Installs MIDI remotes for MIDI-Fighter Twister
-- To be used in conjunction with configured BOME and MidiFighter configuration files

-- Created by Jason Giaffo
-- Last updated Aug 26, 2020
-- Contact: http://giaffodesigns.com/contact/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                local CONFIG = {}
-- All copies and revisions of this code are copyright property of Giaffo Designs and may not be used, in any part or in entirety, without written consent of Jason Giaffo and credit where used. This plugin is only approved for usage by persons who have directly purchased it from GiaffoDesigns.
-- TL;DR: don't be a dick; don't steal people's work; give credit to people



---- Encoder Multiplier Values (config) ----
-- All values must be whole numbers

CONFIG.ATTRIB_ROTATE_MULT = 2           -- for attribute encoders (green)
CONFIG.DIMMER_WHEEL_MULT  = 1           -- for dimmer wheel encoder (pink)
CONFIG.SCREEN_ROTATE_MULT = 1           -- for screen encoders (orange and red)











--------------------------------------------------------------------------------------------
------------------------------ DO NOT EDIT BELOW THIS POINT --------------------------------
--------------------------------------------------------------------------------------------

CONFIG.VERBOSE = false
CONFIG.TEST_MODE = false



 local GDFstr=[==========[
    -- v1.9.6
 local _M = {} local unpack = table.unpack local function cmd(...) gma.cmd(string.format(...)) end local function echo(...) gma.echo(string.format(...)) end local function feedback(...) gma.feedback(string.format(...)) end _M.internal = { counter = function() GD.internal.ct = GD.internal.ct or 0 GD.internal.ct = GD.internal.ct + 1 return GD.internal.ct end } _M.class = { SuperTable = { append = function(self, v, ...) if type(v)=='string' and (...) then v = string.format(v, ...); end; self[#self + 1] = v end, concat = function(self, sep, i, j) return table.concat(self, sep, i, j) end, new = function(self, o) o = o or {} setmetatable(o, self) self.__index = self return o end, shuffle = function(list) local iterations = #list for x = 1, 4 do for i = iterations, 1, -1 do j = math.random(i) list[i], list[j] = list[j], list[i] end end end } } local ST = _M.class.SuperTable _M.class.ObjSet = ST:new{ __tostring = function(self) local t = ST:new{} for _, v in pairs(self) do t:append(v) end return(table.concat(t, ' + ')) end } _M.class.DmxAddress = { __tostring = function(self) return string.format('%d.%03d', self.universe, self.channel); end, ToString = function(self) return tostring(self); end, GetAbsolute = function(self) return ((self.universe - 1) * 512) + self.channel; end, new = function(self, args) local obj = { universe = 0, channel = 0, } if (args) then if (type(args) == 'string') then local universe, channel = args:match('(%d+)%.(%d+)') if (universe) and (channel) then obj.universe = tonumber(universe); obj.channel = tonumber(channel); else error('DmxAddress object could not be build with provided string: '..args); end elseif (type(args) == 'table') then for k, val in pairs(args) do obj[k] = val; end end end setmetatable(obj, self); self.__index = self; return obj; end } _M.class.IPAddress = { IPBasic = { __tostring = function(self) return table.concat(self, '.'); end, ToBinary = function(self) local binTbl = {}; for index, int in ipairs(self) do binTbl[index] = _M.data.IntToBinary(int); end return table.concat(binTbl); end, new = function(self, args) local ip = {}; if (type(args) == 'string') then local bin = args:match('([0-1]+)') if (bin and (#bin == 32)) then for index = 1, 4 do local i = ((index-1) * 8) + 1; local j = i + 7; ip[index] = _M.data.BinaryToInt(bin:sub(i, j)); end else ip = {args:match('(%d+)%.(%d+)%.(%d+)%.(%d+)')} if (#ip ~= 4) then error(args..' provided to class.IPAddress:new().') else for i, v in ipairs(ip) do ip[i] = tonumber(v); end; end end elseif (type(args) == 'table') then if (#args == 4) then for i, v in ipairs(args) do ip[i] = v; end; else error('Improperly formatted table provided to class.IPAddress:new()') end end setmetatable(ip, self); self.__index = self; return ip; end, }, __tostring = function(self) return table.concat(self.ip, '.'); end, GenerateNetMask = function(self) local bin = self.ip:ToBinary(); if bin:find('^0') then self:AssignNetMask{255,0,0,0}; elseif bin:find('^10') then self:AssignNetMask{255,255,0,0}; elseif bin:find('^110') then self:AssignNetMask{255,255,255,0}; else echo('netmask could not be determined. Defaulting to C class.') self:AssignNetMask{255,255,255,0}; end end, AssignNetMask = function(self, args) self.netMask = self.IPBasic:new(args); local netMaskBin = self.netMask:ToBinary(); local subnetBin = _M.data.BinAnd(self.ip:ToBinary(), netMaskBin); local broadcastIDBinary = _M.data.BinOr(subnetBin, _M.data.BinInvert(netMaskBin)) self.subnet = self.IPBasic:new(subnetBin) self.broadcastIP = self.IPBasic:new(broadcastIDBinary) end, new = function(self, args) local obj = {}; obj.ip = self.IPBasic:new(args); setmetatable(obj, self); self.__index = self; return obj; end, } _M.class.Executor = { __tostring = function(self) return string.format('%d.%d', self.page, self.exec) end, GetStatus = function(self) local slotStatus = _M.get.handle('Executor '..tostring(self)); if slotStatus then if _M.get.handle('Executor '..tostring(self)..' Cue') then local c = _M.get.class('Executor '..tostring(self)..' Cue'); if c == "CMD_SEQUENCE" then return 'OFF' elseif c == "CMD_CUE" then return 'ON' end else return 'NON-SEQ' end else return 'EMPTY' end end, new = function(self, o) o = o or {} setmetatable(o, self) self.__index = self return o end, } _M.class.MultipleSelect = { _buttonFunctions = { GetValue = function(self) return self.parent.values[self.tableKey]; end, SetValue = function(self, value) self.parent.values[self.tableKey] = value; end, _FormatValue = function(self, value) if type(value) == 'string' then if self.hideDisplayQuotes then return value; else return '\"'..value..'\"'; end; elseif type(value) == 'number' then if math.floor(value) == value then return string.format('%d', value); else return string.format('%.3f', value); end elseif type(value) == 'boolean' then if (value) then return self.boolStrings[1]; else return self.boolStrings[2]; end; elseif type(value) == 'nil' then return '('..self.nilString..')' elseif type(value) == 'table' then return 'ERROR: table' else return 'TYPE ERROR: '..type(value); end end, }, _msShared = { _InitializeClass = function(self) if (_M.class.MultipleSelect._msShared.colors) then return; end; _M.data.GDpath{'MultipleSelect'}; local colorDefaults = { active = {h=nil, s=100, v=60}, inactive = {h=nil, s=100, v=40}, } local colors = { red = {hue = 0}, orange = {hue = 30}, yellow = {hue = 60}, lime = {hue = 90}, green = {hue = 120}, aqua = {hue = 150}, cyan = {hue = 180}, lightBlue = {hue = 210}, blue = {hue = 240}, violet = {hue = 270}, magenta = {hue = 300}, fuschia = {hue = 330}, grey = { active = {h=0, s=0, v=57}, inactive = {h=0, s=0, v=20}, }, black = { active = {h=0, s=0, v=0}, inactive = {h=0, s=0, v=0}, }, } for name, entry in pairs(colors) do if entry.hue then colors[name] = { active = {h=entry.hue, s=colorDefaults.active.s, v=colorDefaults.active.v}, inactive = {h=entry.hue, s=colorDefaults.inactive.s, v=colorDefaults.inactive.v}, } end end for name, pair in pairs(colors) do for statusKey, entry in pairs(pair) do colors[name][statusKey] = _M.class.Color.Create(entry); end end _M.class.MultipleSelect._msShared.colors = colors; return colors end, AddButton = function(self, args) if (not args) then error('No arguments provided to GDF.class.MultipleSelect:AddButton(tbl:args). Did you call as a field instead of as a method?'); end; local btn = {} if (args.type:lower() == 'valueentry') then btn.type = 'valueEntry'; btn.isNullable = args.isNullable or false; btn.tableKey = args.tableKey; btn.displayName = args.displayName; btn.color = self.colors[args.color] or self.colors.violet; btn.nilString = args.nilString or 'no value'; btn.hideDisplayQuotes = args.hideDisplayQuotes; if (not (args.valueTypes or args.valueFormat)) then btn.valueTypes = args.valueTypes or {string=true, int=true, float=true}; elseif (args.valueFormat) then btn.valueTypes = {string=true}; elseif #args.valueTypes > 0 then btn.valueTypes = {}; for i, v in ipairs(args.valueTypes) do btn.valueTypes[v] = true; end; else btn.valueTypes = args.valueTypes; end btn.inputPrompt = {}; btn.inputPrompt.title = 'Enter value for '..btn.displayName; if args.valueFormat then btn.inputPrompt.prompt = 'Ex: '..args.valueFormat[2]; btn.valueFormat = args.valueFormat[1]; else local vt = btn.valueTypes; if (vt.string and vt.float) then btn.inputPrompt.prompt = 'Enter text or number'; elseif (vt.string and vt.int) then btn.inputPrompt.prompt = 'Enter text or whole number'; elseif (vt.string) then btn.inputPrompt.prompt = 'Enter text' elseif (vt.float) then btn.inputPrompt.prompt = 'Enter number' elseif (vt.int) then btn.inputPrompt.prompt = 'Enter whole number' end end btn.FormatForSequence = function(self) local value = self:GetValue(); local t = {name = string.format('%s: %s', self.displayName, self:_FormatValue(value))}; if value then t.color = self.color.active; else t.color = self.color.inactive; end; return t; end btn.Execute = function(self) while true do local input = gma.textinput(self.inputPrompt.title, self.inputPrompt.prompt) if ((not input) or (input == self.inputPrompt.prompt)) then return 1; elseif (input == '') then if (self.isNullable) then self:SetValue(nil); end return 1; elseif (tonumber(input) and (self.valueTypes.int or self.valueTypes.float)) then input = tonumber(input); if (math.floor(input) ~= input) then if (not self.valueTypes.float) then local m = _M.class.MsgBox:new('Invalid number formatting.'); m:append('Decimal numbers not permitted for this value.'); m:confirm(); return 1; end end self:SetValue(input); return 1; else if (not self.valueTypes.string) then if (self.valueTypes.int or self.valueTypes.float) then local m = class.MsgBox:new('Number inputs only.'); m:append('Only number inputs are permitted for this value.') m:confirm(); else local m = class.MsgBox:new('Value type issue.') m:append('Unknown value type wanted.'); m:append('Please check your code.'); m:confirm(); end return 1; end if (self.valueFormat) then local formatCheck = input:match(self.valueFormat); if (not formatCheck) then local m = _M.class.MsgBox:new('Invalid input formatting.'); m:append('Please check formatting of input.'); m:append(self.inputPrompt.prompt); m:append('Your input: %s', input); m:confirm(); return 1; end end self:SetValue(input); return 1; end end end elseif (args.type:lower() == 'valuetoggle') then btn.type = 'valueToggle'; btn.tableKey = args.tableKey; btn.displayName = args.displayName; btn.color = self.colors[args.color] or self.colors.magenta; btn.boolStrings = args.valueStrings or {'YES', 'NO'}; btn.FormatForSequence = function(self) local t = {} local value = self.parent.values[self.tableKey] or false; t.name = string.format('%s: %s', self.displayName, self:_FormatValue(value)); if value then t.color = self.color.active; else t.color = self.color.inactive; end; return t; end btn.Execute = function(self) if self:GetValue() == true then self:SetValue(false); else self:SetValue(true); end return 1; end elseif (args.type:lower() == 'optionselect') then btn.type = 'optionSelect'; btn.tableKey = args.tableKey; btn.displayName = args.displayName; btn.color = self.colors[args.color] or self.colors.lightBlue; btn.tableValue = args.tableValue or true; btn.FormatForSequence = function(self) return { name = self.displayName, color = self.color.active, } end btn.Execute = function(self) self:SetValue(self.tableValue); return 0; end elseif (args.type:lower() == 'multipleselect') then btn.type = 'multipleSelect'; btn.tableKey = args.tableKey; btn.displayName = args.displayName; btn.color = self.colors[args.color] or self.colors.aqua; btn.MenuPopulate = args.MenuPopulate; if (not btn.MenuPopulate) then error("no population function provided to button type \"multipleSelect\" in GDF.class.MultipleSelect."); end btn.FormatForSequence = function(self) local value = self:GetValue(); local t = {name = string.format('%s: %s', self.displayName, self:_FormatValue(value))}; if value then t.color = self.color.active; else t.color = self.color.inactive; end; return t; end btn.Execute = function(self) local ms = _M.class.MultipleSelect.Create{modeHardCancel=true}; self.MenuPopulate(ms); local exitCode = ms:Execute(); if (exitCode ~= -1) then self:SetValue(ms.values.value); end return 1; end elseif (args.type:lower() == 'popup') then btn.type = 'popup'; btn.displayName = args.displayName; btn.color = self.colors[args.color] or self.colors.orange; btn.msgbox = args.msgbox; if (not btn.msgbox) then error('no MsgBox item provided to Popup button in GDF.class.MultipleSelect:AddButton().'); end; btn.FormatForSequence = function(self) return { name = self.displayName, color = self.color.active, } end btn.Execute = function(self) self.msgbox:confirm(); return 1; end elseif (args.type:lower() == 'continue') then btn.type = 'continue'; btn.color = self.colors[args.color] or self.colors.green; btn.FormatForSequence = function(self) return { name = 'CONTINUE', color = self.color.active, } end btn.Execute = function(self) return 0; end elseif (args.type:lower() == 'cancel') then btn.type = 'cancel'; btn.color = self.colors[args.color] or self.colors.red; btn.FormatForSequence = function(self) return { name = 'CANCEL', color = self.color.active, } end btn.Execute = function(self) return -1; end elseif (args.type:lower() == 'blank') then btn.type = 'blank'; btn.color = self.colors.black; btn.FormatForSequence = function(self) return { name = '   ', color = self.color.active, } end btn.Execute = function(self) return 1; end elseif (args.type:lower() == 'note') then btn.type= 'note'; btn.color = self.colors[args.color] or self.colors.grey; btn.displayName = args.displayName or '   '; btn.FormatForSequence = function(self) return { name = self.displayName, color = self.color.inactive, } end btn.Execute = function(self) return 1; end end btn.parent = self; setmetatable(btn, {__index = _M.class.MultipleSelect._buttonFunctions}) self.buttons:append(btn); end, _GenerateCmdSequence = function(self) local D = self.debugStream; D:startLine('Starting CmdSeq build for MultipleSelect menu...') if (not self.sequence) then error('Attempt to generate CmdSeq for GDF.class.MultipleSelect without a Sequence slot allocated.'); end; if (not self.executor) then error('Attempt to generate CmdSeq for GDF.class.MultipleSelect without an Executor slot allocated.'); end; if (not self.macro) then error('Attempt to generate CmdSeq for GDF.class.MultipleSelect without a storage Macro slot allocated.'); end; local cmdTemplate = [[Assign Macro 1.%d.1 /info="%d"]] local cmdSeq = _M.class.CmdSeq:new{name='OptionSelect', num=self.sequence}; for i, btn in ipairs(self.buttons) do local cmdForCue = cmdTemplate:format(self.macro, i); local display = btn:FormatForSequence(); cmdSeq:newline{ cue=i, name=display.name, cmd=cmdForCue, appearance=display.color:ToString('hex'), mode='release' } end D:write('writing...'); cmdSeq:write{forceOverwrite=true}; D:write('OK\n'); if (not self.sequenceIsAssigned) then cmd('Assign Sequence %d At Executor %s', self.sequence, tostring(self.executor)); self.sequenceIsAssigned = true; end end, _HandleCancellation = function(self) local confirmCancel = false; if (self.modeHardCancel) then confirmCancel = true; else confirmCancel = _M.gui.ConfirmCancellation(); end; if (confirmCancel) then self:Terminate(); self.debugStream:writeLine('MS Menu cancelled.') return true; end end, _SetResponseValue = function(self, value) if (self.macro) then cmd('Assign Macro 1.%d.1 /info="%s"', self.macro, tostring(value)); else error('GDF.MultipleSelect._SetResponseValue(val): Attempt to set value in non-initialized storage macro.') end end, _GetResponseValue = function(self) if (self.macro) then return tonumber(_M.get.prop('Macro 1.'..self.macro..'.1', 'info')); else error('GDF.MultipleSelect._GetResponseValue(val): Attempt to retrieve value from non-initialized storage macro.') end end, Execute = function(self) local gdLocal = GD.MultipleSelect; local D = self.debugStream; self.sequence = _M.poolitem.advanceSpace('Sequence', 5000, 1); self.executor = _M.exec.advance(1, 191, 1, 191) self.macro = _M.poolitem.advanceSpace('Macro', 5000, 1); self.macroInfo = 'MS '..gma.network.getprimaryip(); local mac = _M.class.Macro:new{num=self.macro, name='MS Storage', info=self.macroInfo}; mac:newline{info=[[-2]]} mac:write(); local loopCt = 0; while true do if (_M.get.prop('Macro '..self.macro, 'info') == self.macroInfo) then break; end gma.sleep(0.02) loopCt = loopCt + 1; if (loopCt > 15) then self:Terminate(); error('MultipleSelect macro could not be created.'); end end D:writeLine('Starting MS menu execution.') while true do self:_SetResponseValue(-2); self:_GenerateCmdSequence(); D:cmd('Goto Executor %s', self.executor) local loopCt = 0; while (self:_GetResponseValue() == -2) do gma.sleep(0.02); loopCt = loopCt + 1; if (loopCt >= 10) then break; end; end local responseVal = self:_GetResponseValue() D:writeLineI('Received value: '..responseVal); if (responseVal == -2) then if (self:_HandleCancellation()) then return -1; end; elseif self.buttons[responseVal] then local code = self.buttons[responseVal]:Execute(); if (code == 0) then self:Terminate(); return 0; elseif (code == -1) then if (self:_HandleCancellation()) then return -1; end; end else local errMsg = string.format('Value provided: %d --- #buttonsTable: %d --- Matching button could not be found.', responseVal, #self.buttons); D:writeLine(errMsg); self:Terminate(); error(errMsg); end end end, Terminate = function(self) if (self.sequence) then cmd('Unlock Sequence %d', self.sequence); cmd('Delete /nc Sequence %d', self.sequence); end if (self.macro) then cmd('Unlock Macro %d', self.macro); cmd('Delete /nc Macro %d', self.macro); end self.sequence = nil; self.executor = nil; self.macro = nil; self.macroInfo = nil; self.sequenceIsAssigned = false; end, }, Create = function(args) local args = args or {}; local t = { sequence = nil, executor = nil, sequenceIsAssigned = false; buttons = ST:new{}, values = args.values or {}, debugStream = args.debugStream or _M.class.DebugStream:new(), modeHardCancel = args.modeHardCancel, } setmetatable(t, {__index=_M.class.MultipleSelect._msShared}) t:_InitializeClass(); return t; end } _M.class.Queue = ST:new{ enqueue = function(self, data) self:append(data) end, dequeue = function(self) local t = self[1] table.remove(self, 1) return t end, peek = function(self) return(self[1]) end } _M.class.XmlWriter = { BuildStartElement = function(self, key, attributes) self.lines:append('%s<%s%s>', string.rep('\t', #self.tree), key, _M.xml.ConvertToAttributeString(attributes)); table.insert(self.tree, 1, key); end, BuildEndElement = function(self) self.lines:append('%s</%s>', string.rep('\t', #self.tree-1), self.tree[1]); table.remove(self.tree, 1); end, BuildSingleLineElement = function(self, key, attributes, value) if (value) then self.lines:append('%s<%s%s>%s</%s>', string.rep('\t', #self.tree), key, _M.xml.ConvertToAttributeString(attributes), _M.xml.format(value), key ) else self.lines:append('%s<%s%s />', string.rep('\t', #self.tree), key, _M.xml.ConvertToAttributeString(attributes) ) end end, Initialize = function(self) if (not self.isNotMAFile) then self:BuildStartElement('MA', { ['xmlns:xsi'] = "http://www.w3.org/2001/XMLSchema-instance", xmlns = "http://schemas.malighting.de/grandma2/xml/MA", ['xsi:schemaLocation'] = "http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.9.0/MA.xsd", major_vers = self.vers[1], minor_vers = self.vers[2], stream_vers = self.vers[3], }) self:BuildSingleLineElement('Info', { datetime = "2020-07-22T11:20:25", showfile = "page flash installer test", }) end end, Finalize = function(self) while #self.tree > 0 do self:BuildEndElement(); end self.script = table.concat(self.lines, '\n'); return self.script; end, Create = function(options) local options = options or {}; local obj = {}; obj.tree = {}; obj.lines = ST:new{}; obj.script = ''; if (options.prolog) then table.insert(obj.lines, options.prolog); end; obj.isNotMAFile = options.isNotMAFile; obj.vers = options.vers or {3, 0, 0}; setmetatable(obj, {__index = _M.class.XmlWriter}) return obj; end } _M.class.DebugStream = ST:new{ new = function(self, args) local obj = {}; local args = args or {}; obj.filename = args.filename or 'DEBUG_Default.txt'; file = nil; verbose = args.verbose or false; setmetatable(obj, self); self.__index = self; return obj; end, path = gma.show.getvar('path')..'/reports/', tab = "\t", indent_level = 0, spacer = string.rep('-', 70), initialize = function(self, filename, path) if path then self.path = path else self.path = gma.show.getvar('path')..'/reports/' end if filename then self.filename = filename end self.file = assert(io.open(self.path..self.filename, 'w')) self.fullpath = self.path..self.filename; return o end, setIndent = function(self, val, rel) if (rel) then self.indent_level = self.indent_level + val; else self.indent_level = val; end; if (self.indent_level < 0) then self.indent_level = 0; end; end, close = function(self) if (self.file) then self.file:close(); self.file = nil; end end, delete = function(self) if (self.file) then self.file:close(); os.remove(self.path..self.filename); self.file = nil; end end, write = function(self, ...) if (self.file) then self.file:write(string.format(...)); end if self.verbose then gma.echo(string.format(...)); end; end, startLine = function(self, ...) if (self.file) then self.file:write(self.tab:rep(self.indent_level) .. string.format(...)); end if self.verbose then gma.echo(string.format(...)); end; end, startLineI = function(self, ...) if (self.file) then self.file:write(self.tab:rep(self.indent_level + 1) .. string.format(...)); end if self.verbose then gma.echo(string.format(...)); end; end, writeLine = function(self, ...) if (self.file) then self.file:write(self.tab:rep(self.indent_level) .. string.format(...) .. '\n'); end; if self.verbose then gma.echo(string.format(...)); end; end, writeLineI = function(self, ...) if (self.file) then self.file:write(self.tab:rep(self.indent_level + 1) .. string.format(...) .. '\n'); end; if self.verbose then gma.echo(string.format(...)); end; end, lineBreak = function(self) if (self.file) then self.file:write(self.spacer..'\n'); end end, cmd = function(self, ...) cmd(...); self:writeLine('CMD: ' .. string.format(...)); end, echo = function(self, ...) echo(...); self:writeLine('ECHO: ' .. string.format(...)); end, getFile = function(self) return self.fullpath end, copyToAllDrives = function(self, opt) if (not self.fullpath) then return; end; local verbose = false; local v_print = function(...) if (verbose) then gma.echo(string.format(...)); end; end if (opt and opt.verbose) then verbose = true; end; local paths = _M.data.getPaths({'reports'}, verbose) v_print('#paths: '..#paths) local trig_reopen = false; if self.file then self.file:close(); trig_reopen = true; end v_print('opening: '..self.fullpath) local rf, err = io.open(self.fullpath, 'r'); if (not rf) then error('DebugStream:copyToAllDrives() - DEBUGSTREAM FILE COULD NOT BE OPENED IN READ MODE'); end; local data = rf:read('*a') v_print('#data: '..#data) for i, path in ipairs(paths) do v_print('TRYING: '..path) local wf, err = io.open(path..self.filename, 'w') if (not err) then v_print('...success') wf:write(data); wf:close(); gma.echo('DEBUG LOG COPIED TO\n'..path..self.filename) end end if (trig_reopen) then self.file = io.open(self.fullpath, 'a') end end } _M.class.Macro = _M.class.SuperTable:new{ import = function(self, ref) if not _M.get.verify('Macro '..ref) then return nil, 'Error: requested macro does not exist' end local script = _M.get.script('Macro '..ref, 'macros') self.name = _M.get.name('Macro '..ref) self.num = _M.get.number('Macro '..ref) for match in script:gmatch('<Macroline index=.-</Macroline>') do local t = {} local num = match:match('Macroline index="(%d+)"') t.num = tonumber(num) + 1 if not self.lines then self.lines = ST:new() end while t.num > #self.lines do self:newline({}) end local cmd = match:match('<text>(.-)</text>') if cmd then t.cmd = cmd:gsub('&quot;', '"') end local info = match:match('<info>(.-)</info>') if info then t.info = info:gsub('&quot;', '"') end local wait = match:match('delay = \"(.-)\"') if wait then t.wait = tonumber(wait) end self:newline(t) end end, newline = function(self, list) if (not self.lines) then self.lines = _M.class.SuperTable:new(); end if list.cmd and type(list.cmd) == 'table' then list.cmd = string.format(table.unpack(list.cmd)) end self.lines:append{ cmd = list.cmd, wait = list.wait, info = list.info, disabled = list.disabled } end, write = function(self, force_overwrite) local d_stream = self.debugStream or _M.class.DebugStream:new(); d_stream:startLineI('Writing Macro %d "%s"...', self.num, self.name); local num = self.num local name = self.name or 'Macro '..tonumber(num) local macInfo = self.info if macInfo then macInfo = macInfo:gsub([["]], [[&quot;]]); macInfo = macInfo:gsub([[<]], [[&lt;]]); macInfo = macInfo:gsub([[>]], [[&gt;]]); macInfo = macInfo:gsub('%%', '%%%%'); end local script = string.format("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MA xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.malighting.de/grandma2/xml/MA\" xsi:schemaLocation=\"http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.2.2/MA.xsd\" major_vers=\"3\" minor_vers=\"0\" stream_vers=\"0\">\n    <Info datetime=\"2017-01-07T23:39:00\" showfile=\"Ye Olde Bag O Phallus\" />\n    <Macro index=\"1\" name=\"%s\">\n", name) if macInfo then script = script..string.format("            <InfoItems>\n                <Info date=\"2019-06-23T16:20:45\">%s</Info>\n            </InfoItems>\n" , macInfo) end for i, v in ipairs(self.lines) do local cmd = self.lines[i].cmd local wait = self.lines[i].wait local info = self.lines[i].info local disabled = self.lines[i].disabled if cmd then cmd = cmd:gsub([["]], [[&quot;]]) end if info then info = info:gsub([["]], [[&quot;]]) end local t = string.format("        <Macroline index=\"%d\"", i-1) if type(wait) == 'string' and wait:upper() == 'GO' then t = t..[[ delay="-1" ]] elseif wait then t = t..[[ delay="]]..wait..[["]] end if disabled then t = t..[[ disabled="true"]] end if (not cmd) and (not info) then t = t..[[ />]]..'\n' else t = t..[[>]]..'\n' if cmd then t = t..string.format("            <text>%s</text>\n", cmd) end if info then t = t..string.format("            <info>%s</info>\n", info) end t = t.."                </Macroline>\n" script = script..t end end script = script.."    </Macro>\n</MA>" local macFile = {} macFile.name = 'tempFile_createMacro.xml' macFile.dir = gma.show.getvar('PATH')..'/'..'macros/' macFile.fullpath = macFile.dir..macFile.name local writeFile = io.open(macFile.fullpath, 'w') writeFile:write(script) writeFile:close() local importcmd = 'Import \"'..macFile.name..'\" Macro '..num if force_overwrite then importcmd = importcmd..' /o /nc' end gma.cmd('SelectDrive 1') gma.cmd(importcmd) os.remove(macFile.fullpath) gma.cmd('Label Macro '..num..' \"'..name..'\"') if _M.get.verify('Macro '..num) then d_stream:write('OK\n') else d_stream:write('FAILED\n') end end, } _M.class.CmdSeq = ST:new{ name = '', num = '', newline = function(self, args) if (not self.lines) then self.lines = _M.class.SuperTable:new() end if (not self.line_ref) then self.line_ref = {} end local current; if (not self.line_ref[args.cue]) then self.lines:append{num = args.cue} self.line_ref[args.cue] = self.lines[#self.lines] current = self.lines[#self.lines] else current = self.line_ref[args.cue] end current.mode = current.mode or args.mode; local part = args.part or 0 current[part] = { cmd = args.cmd, name = args.name or 'Cue', appearance = args.appearance, } end, write = function(self, args) local args = args or {}; local sort_cues = function(a, b) return (a.num < b.num) end table.sort(self.lines, sort_cues) local prolog = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"styles/sequ@html@default.xsl\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"styles/sequ@executorsheet.xsl\" alternate=\"yes\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"styles/sequ@trackingsheet.xsl\" alternate=\"yes\"?>" local writer = _M.class.XmlWriter.Create{prolog=prolog}; writer:Initialize(); writer:BuildSingleLineElement('Info', {datetime="2019-03-17T17:15:00", showfile="poopie"}); writer:BuildStartElement('Sequ', {index=(self.num-1), name=self.name}); if self.appearance then writer:BuildSingleLineElement('Appearance', {Color=self.appearance}); end; if self.info then writer:BuildStartElement('InfoItems'); writer:BuildSingleLineElement('Info', {date="2019-12-09T15:34:16"}, self.info); writer:BuildEndElement(); end writer:BuildSingleLineElement('Cue', {['xsi:nil']=true}); for index, cue in pairs(self.lines) do writer:BuildStartElement('Cue', {index=index, cue_mode=cue.mode}); local numStr = string.format('%.03f', cue.num) local whole, rem = numStr:match('(%d+)%.(%d%d%d)') if tonumber(rem) == 0 then rem = '0'; end; writer:BuildSingleLineElement('Number', {number=whole, sub_number=rem}) for part = 0, #cue do writer:BuildStartElement('CuePart', {index=part, name=cue[part].name}) if cue[part].appearance then writer:BuildSingleLineElement('Appearance', {Color=cue[part].appearance}) end if cue[part].cmd then writer:BuildSingleLineElement('macro_text', nil, cue[part].cmd); end writer:BuildEndElement(); end writer:BuildEndElement(); end writer:Finalize(); _M.poolitem.generate('Sequence '..self.num, writer.script, {forceOverwrite=args.forceOverwrite}) end } _M.class.Color = ST:new{ Create = function(initArgs) local function HsvToRgb(hue, sat, val) sat = sat / 100; val = val / 100; if sat == 0 then val = math.floor(val * 255); return val, val, val; end; local hueSector = math.floor( hue / 60 ); local hueSectorOffset = ( hue / 60 ) - hueSector; local p = val * ( 1 - sat ); local q = val * ( 1 - sat * hueSectorOffset ); local t = val * ( 1 - sat * ( 1 - hueSectorOffset ) ); local rgb; if (hueSector == 0) then rgb = {val, t, p}; elseif (hueSector == 1) then rgb = {q, val, p}; elseif (hueSector == 2) then rgb = {p, val, t}; elseif (hueSector == 3) then rgb = {p, q, val}; elseif (hueSector == 4) then rgb = {t, p, val}; elseif (hueSector == 5) then rgb = {val, p, q}; end for i, v in ipairs(rgb) do rgb[i] = math.floor(v*255); if (rgb[i] < 0) then rgb[i] = 0; end; end return unpack(rgb); end local function RgbToHsv(red, green, blue) red = red / 2.55; green = green / 2.55; blue = blue / 2.55 local hue, sat, val; local minValue = math.min(red, green, blue); local maxValue = math.max(red, green, blue); val = maxValue; local valueDelta = maxValue - minValue; if maxValue == 0 then return 0, 0, 0; else sat = (valueDelta / maxValue) * 100; end; if red == maxValue then hue = ( green - blue ) / valueDelta; elseif green == maxValue then hue = 2 + ( blue - red ) / valueDelta; else hue = 4 + ( red - green ) / valueDelta; end; hue = hue * 60; if (hue < 0) then hue = hue + 360; end; return hue, sat, val; end local obj = {} obj.SetValues = function(self, args) if (args.h and args.s and args.v) then self.h = args.h; self.s = args.s; self.v = args.v; self.r, self.g, self.b = HsvToRgb(args.h, args.s, args.v) elseif (args.r and args.g and args.b) then if ((args.mode) and (args.mode == 'percent')) then self.r = tonumber(string.format('%.0f', args.r * 2.55)); self.g = tonumber(string.format('%.0f', args.g * 2.55)); self.b = tonumber(string.format('%.0f', args.b * 2.55)); else self.r = args.r; self.g = args.g; self.b = args.b; end self.h, self.s, self.v = RgbToHsv(self.r, self.g, self.b) else self.r, self.g, self.b = 0, 0, 0; self.h, self.s, self.v = 0, 0, 0; end end obj.ToString = function(self, mode) mode = mode or 'hex'; if (mode == 'hex') then return string.format('%02x%02x%02x', self.r, self.g, self.b); elseif (mode == 'appearance') then return string.format('/r=%.0f /g=%.0f /b=%.0f', (self.r/2.55), (self.g/2.55), (self.b/2.55)); end end obj.GetValues = function(self, mode) if (not mode) then error('No mode was provided to Color:GetValues(str:mode)'); end; if mode == 'percent' then return { self.r / 2.55, self.g / 2.55, self.b / 2.55, } elseif mode == 'hex' then return { string.format('%02x', self.r), string.format('%02x', self.g), string.format('%02x', self.b), } end end obj:SetValues(initArgs); return obj; end } _M.class.MsgBox = ST:new{ new = function(self, o) local tbl = {} if type(o) == 'string' then tbl.title = o; else tbl = o; end; setmetatable(tbl, self) self.__index = self return tbl end, title = '', confirm = function(self) return gma.gui.confirm(self.title, table.concat(self, '\n')) end, msgbox = function(self) return gma.gui.msgbox(self.title, table.concat(self, '\n')) end, print = function(self) for _, v in ipairs(self) do gma.echo(v) gma.feedback(v) end end, ToString = function(self) return table.concat(self, '\n') end, } _M.class.ProgressBar = ST:new{ new = function(self, name) o = {handle = gma.gui.progress.start(name)}; o.name = name; o.text = ''; o.value = 0; o.range = {top=0, bottom=0}; setmetatable(o, self) self.__index = self self.name = name return o end, set = function(self, num, add) if add then num = self.value + num end num = math.floor(num) gma.gui.progress.set(self.handle, num) self.value = num end, setrange = function(self, bottom, top) if not bottom or not top then return nil end gma.gui.progress.setrange(self.handle, bottom, top) self.range = {top = top, bottom = bottom} end, settext = function(self, text) gma.gui.progress.settext(self.handle, text); self.text = text; end, rename = function(self, name) gma.gui.progress.stop(self.handle) self.handle = gma.gui.progress.start(name) self.name = name; if self.range then gma.gui.progress.setrange(self.handle, self.range.bottom, self.range.top) end end, stop = function(self) gma.gui.progress.stop(self.handle); self.paused = false; self.stopped = true; end, pause = function(self) gma.gui.progress.stop(self.handle); if (not self.stopped) then self.paused = true; end; end, resume = function(self) if self.paused then self.paused = false; self.handle = gma.gui.progress.start(self.name); if self.text ~= '' then gma.gui.progress.settext(self.handle, self.text); end; if self.range.top ~= 0 then gma.gui.progress.setrange(self.handle, self.range.bottom, self.range.top); end; gma.gui.progress.set(self.handle, self.value) end end, time_move = function(self, target, time, add, ignore_top) if add then target = self.value + target end local start = self.value local finish = math.floor(target) local sleepPeriod if math.abs(time) ~= time then sleepPeriod = (1 / time) else sleepPeriod = time / (math.abs(finish - start)) end if not ignore_top and self.range and finish > self.range.top then finish = self.range.top end local dir = 1 if start > finish then dir = -1 end for i = start, finish, dir do self:set(i) gma.sleep(sleepPeriod) end end } _M.oop = { SetPropertiesTable = function(orig, meta) local function getFromMeta(t, key) local meta = getmetatable(t).mymeta local t = rawget(meta, key) if (type(t) ~= 'nil') then return t; end; end local function setInMeta(t, key, val) local meta = getmetatable(t).mymeta if (type(rawget(meta, key) ~= 'nil')) then rawset(meta, key, val); else rawset(t, key, val) end; end setmetatable(orig, {__index=getFromMeta, __newindex=setInMeta, mymeta=meta}) end, } _M.lo = { layout = ST:new{ name = nil, num = nil, info = nil, bg_col = '000000', grid = {0, 0}, snap_grid = {0.5, 0.5}, size = {x = 0, y = 0}, bound = {x = {}, y = {}}, rebound = function(self, obj) local size = {obj.size.x or obj.size[1], obj.size.y or obj.size[2]} local coord = {obj.coord.x or obj.coord[1], obj.coord.y or obj.coord[2]} if not obj.bound then obj.bound = { x = { min = coord[1] - (size[1]/2), max = coord[1] + (size[1]/2), }, y = { min = coord[2] - (size[2]/2), max = coord[2] + (size[2]/2), } } end if not self.bound.x.min then self.bound = obj.bound else for k, v in pairs(self.bound) do self.bound[k].max = math.max(v.max, obj.bound[k].max) self.bound[k].min = math.min(v.min, obj.bound[k].min) end end for k, v in pairs(self.bound) do self.size[k] = math.abs(self.bound[k].max - self.bound[k].min) end end, obj = ST:new{ id = 'obj', obj = { type = nil, num = nil }, img = nil, coord = { x = 0, y = 0, }, size = { x = 0.95, y = 0.95 }, icon = { vis = 'Simple', bg = '3c3c3c', border = '5a5a5a', icon = 'None', }, text = { text = '', size = 2, color = nil, show_id = false, show_name = false, show_type = false, } }, box = ST:new{ id = 'box', bg = '00000000', border = 'ffffff', img = nil, coord = { x = 0, y = 0, }, size = { x = 0.95, y = 0.95, }, text = { text = '', show_id = true, show_name = true, show_type = true, }, active = { show_dVal = false, show_dBar = false, select_grp = false, }, }, addobj = function(self, config) if self.debug and self.debug.obj then self.debug.stream:startLineI('Adding %s %d to Layout %d ', config.obj.type, config.obj.num, self.num) if config.img then self.debug.stream:write('with Image %d\n', config.img); else self.debug.stream:write('WITHOUT image.\n'); end; end if (not self.collection) then self.collection = ST:new{ obj = ST:new(), box = ST:new(), } end local t = self.obj:new(config) self.collection.obj:append(t) self:rebound(t) return t end, addbox = function(self, config) if self.debug and self.debug.obj then self.debug.stream:startLineI('Adding box Layout %d ', self.num) if config.img then self.debug.stream:write('with Image %d\n', config.img); else self.debug.stream:write('WITHOUT image.\n'); end; end if config.bounds then local d = config.bounds config.size = { x = math.abs(d.x[2] - d.x[1]), y = math.abs(d.y[2] - d.y[1]) } config.coord = { x = (d.x[1] + d.x[2])/2, y = (d.y[1] + d.y[2])/2, } end if not self.collection then self.collection = ST:new{ obj = ST:new(), box = ST:new(), } end local t = self.box:new(config) self.collection.box:append(t) self:rebound(t) return t end, shift = function(self, x, y) if x and y and type(x) == 'number' and type(y) == 'number' then for _, v in pairs(self.collection) do for _, obj in ipairs(v) do obj.coord.x = obj.coord.x + x obj.coord.y = obj.coord.y + y end end for k, v in pairs(self.bound.x) do self.bound.x[k] = v + x end for k, v in pairs(self.bound.y) do self.bound.y[k] = v + y end else return nil, 'error: invalid data for LO-shift' end end, scale = function(self, x, y) local scl = { x = x or 1, y = y or 1, } local avg = function(a, b) if type(a) == 'table' and (not b) then return ((a.min + a.max)/2) elseif type(a) == 'table' and type(b) == 'table' then return ((a + b)/2) end end local mast = { cent = { x = avg(self.bound.x), y = avg(self.bound.y), }, size = { x = (self.bound.x.max - self.bound.x.min) * scl.x, y = (self.bound.y.max - self.bound.y.min) * scl.y } } for k, v in self.bound do self.bound[k].min = mast.cent[k] - (mast.size[k]/2) self.bound[k].max = mast.cent[k] + (mast.size[k]/2) end for type, v in pairs(self.collection) do for i, obj in ipairs(v) do local l = self.collection[type][i] l.coord.x = (l.coord.x or l.coord[1]) + (((l.coord.x or l.coord[1]) - mast.cent.x) * scl.x) l.coord.y = (l.coord.y or l.coord[2]) + (((l.coord.y or l.coord[2]) - mast.cent.y) * scl.y) l.size.x = l.size.x * scl.x l.size.y = l.size.y * scl.y end end end, merge = function(self, other) self:rebound(other) for type, table in pairs(other.collection) do for i, v in ipairs(table) do self.collection[type]:append(v) end end end, write = function(self, config) local dStream = nil; if self.debug and self.debug.write then dStream = self.debug.stream; end; if dStream then dStream:startLine('Writing Layout %d "%s"...', self.num, self.name); end; local function d_write(trig, ...) if config.debug and config.debug[trig] then self.debug.stream:writeLineI(...) end end local trunc = _M.data.trunc local scr = ST:new() local function write_obj(scr, obj_table) local self_trig = 'write_obj' scr:append("            <CObjects>\n") for _, v in ipairs(obj_table) do local x = trunc(v.coord.x or v.coord[1], 0.001) local y = trunc(v.coord.y or v.coord[2], 0.001) local size_x = trunc(v.size.x or v.size[1], 0.001) local size_y = trunc(v.size.y or v.size[2], 0.001) x = x + (size_x / 2) y = y + (size_y / 2) local show_id, show_name, show_type, font_size, font_color if v.text.show_id == true then show_id = [[show_id="1" ]]; else show_id = ''; end; if v.text.show_name == true then show_name = [[show_name="1" ]]; else show_name = ''; end; if v.text.show_type == true then show_type = [[show_type="1" ]]; else show_type = ''; end; local fSizeTbl = {'font_size="Small" ', '', 'font_size="Big" '} font_size = fSizeTbl[v.text.size] or '' if v.text.color then font_color = 'text_color="'..v.text.color..'" '; else font_color = ''; end scr:append([[                <LayoutCObject ]]..font_size..[[ center_x="]]..x..[[" center_y="]]..y..[[" size_h="]]..size_y..[[" size_w="]]..size_x..[[" background_color="]]..v.icon.bg..[[" border_color="]]..v.icon.border..[[" ]]..font_color..[[icon="]]..v.icon.icon..[[" ]]..show_id..show_name..show_type..[[function_type="]]..v.icon.vis..[[" select_group="1">]]..'\n') if tonumber(v.img) and tonumber(v.img) > 0 and _M.get.verify('Image '..v.img) then local rootnum = _M.get.rootnum('Image', v.img) local name = _M.get.label('Image '..v.img) scr:append("                    <image name=\"%s\">\n                        <No>%d</No>\n                        <No>%d</No>\n                    </image>\n" , name, rootnum[1], rootnum[2]); else if ( (not v.img) or (not _M.get.verify('Image '..v.img)) ) then local mag = _M.gui.tcol.magenta echo(mag..('Image verification failed.')) echo(mag..'variable type: '..type(v.img)) echo(mag..tostring(v.img)) echo('') end scr:append("                    <image />\n") end local w_obj = { name = _M.get.label(v.obj.type..' '..v.obj.num), rootnum = _M.get.rootnum(v.obj.type, v.obj.num) } scr:append("                    <CObject name=\"%s\">\n", tostring(w_obj.name)); for i = 1, #w_obj.rootnum do scr:append("                        <No>%d</No>\n", w_obj.rootnum[i]); end scr:append("                    </CObject>\n"); scr:append("                </LayoutCObject>\n"); end scr:append("            </CObjects>\n") end local function tbl_print(tbl) if dStream then for k, v in pairs(tbl) do if type(v) ~= 'table' then dStream:writeLine('%s: %s', tostring(k), tostring(v)) else dStream:writeLine('%s: TABLE', tostring(k)) dStream:setIndent(1, true) tbl_print(v) dStream:setIndent(-1, true) end end end end local function write_box(scr, box_table) scr:append("            <Rectangles>\n"); for _, v in ipairs(box_table) do local x = trunc(v.coord.x or v.coord[1], 0.001) local y = trunc(v.coord.y or v.coord[2], 0.001) local size_x = trunc(v.size.x or v.size[1], 0.001) local size_y = trunc(v.size.y or v.size[2], 0.001) local show_id, show_name, show_type, show_dVal, show_dBar if v.text.show_id == true then show_id = [[show_id="1" ]]; else show_id = ''; end; if v.text.show_name == true then show_name = [[show_name="1" ]]; else show_name = ''; end; if v.text.show_type == true then show_type = [[show_type="1" ]]; else show_type = ''; end; local show_dimmerVal; if v.active.show_dVal then show_dimmerVal = [[show_dimmer_value="Off" ]]; else show_dimmerVal = ''; end; local show_dimmerBar; if v.active.show_dBar then show_dimmerBar = [[show_dimmer_bar="Off" ]]; else show_dimmerBar = ''; end; local select_grp; if v.active.select_grp then select_grp = [[select_group="1" ]]; else select_grp = ''; end; scr:append([[                <LayoutElement font_size="Small" center_x="]]..x..[[" center_y="]]..y..[[" size_h="]]..size_y..[[" size_w="]]..size_x..[[" background_color="]]..v.bg..[[" border_color="]]..v.border..[[" icon="None" text="]]..v.text.text..[[" ]]..show_id..show_name..show_type..show_dimmerBar..show_dimmerVal..select_grp..">\n") if tonumber(v.img) and tonumber(v.img) > 0 and _M.get.verify('Image '..v.img) then local rootnum = _M.get.rootnum('Image', v.img) local name = _M.get.label('Image '..v.img) scr:append("                    <image name=\"%s\">\n                        <No>%d</No>\n                        <No>%d</No>\n                    </image>\n" , name, rootnum[1], rootnum[2]); else scr:append("                    <image />\n"); end scr:append("                </LayoutElement>\n") end scr:append("            </Rectangles>\n") end scr:append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MA xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.malighting.de/grandma2/xml/MA\" xsi:schemaLocation=\"http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.2.2/MA.xsd\" major_vers=\"3\" minor_vers=\"1\" stream_vers=\"2\">\n    <Info datetime=\"2016-10-18T14:28:09\" showfile=\"xml_scripting\" />\n    <Group index=\"0\" name=\"%s\">\n" , self.name); if self.info then local info = self.info info = info:gsub([["]], [[&quot;]]); info = info:gsub([[<]], [[&lt;]]); info = info:gsub([[>]], [[&gt;]]); info = info:gsub('%%', '%%%%'); scr:append("        <InfoItems>\n            <Info date=\"2019-12-09T15:34:16\">%s</Info>\n        </InfoItems>\n", info); gma.echo(table.concat(scr)) else gma.echo('NO LAYOUT INFO FIELD TO ADD') end scr:append([[        <LayoutData index="0" marker_visible="true" background_color="]]..self.bg_col..[[" visible_grid_h="]]..self.grid[2]..[[" visible_grid_w="]]..self.grid[1]..[[" snap_grid_h="]]..self.snap_grid[2]..[[" snap_grid_w="]]..self.snap_grid[2]..[[" default_gauge="Filled &amp; Symbol" subfixture_view_mode="DMX Layer">]]..'\n') if #self.collection.obj > 0 then write_obj(scr, self.collection.obj) end if #self.collection.box > 0 then write_box(scr, self.collection.box) end scr:append("        </LayoutData>\n    </Group>\n</MA>"); local fn = {temp = 'temp_layoutgen.xml'} local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.imex = dir.main..'importexport/' local file = {temp = dir.imex..fn.temp} local wf = io.open(file.temp, 'w') wf:write(scr:concat()) wf:close() gma.cmd('Import \"'..fn.temp..'\" Layout '..self.num) if (not (config and config.debug)) then os.remove(file.temp) end if (dStream) then if _M.get.verify('Layout '..self.num) then dStream:write('OK\n') else dStream:write('FAILED\n') end end end }, spacingTable = function(tbl) local x = { ct = tbl.dim[1] or 1, int = tbl.space[1] + tbl.size[1] or 1, } if tbl.iscent[1] then x.start = tbl.start[1] - ((x.ct-1) * x.int * 0.5) else x.start = tbl.start[1] end x.pos = x.start local y = { ct = tbl.dim[2] or 1, int = tbl.space[2] + tbl.size[2] or 1, } if tbl.iscent[2] then y.start = tbl.start[2] - ((y.ct-1) * y.int * 0.5) else y.start = tbl.start[2] end y.pos = y.start local t = ST:new{} local loops = 1 if tbl.first.y then for col = 1, x.ct do for row = 1, y.ct do t[loops] = {x.pos, y.pos} y.pos = y.pos + y.int loops = loops + 1 end x.pos = x.pos + x.int y.pos = y.start end else for row = 1, y.ct do for col = 1, x.ct do t[loops] = {x.pos, y.pos} x.pos = x.pos + x.int loops = loops + 1 end y.pos = y.pos + y.int x.pos = x.start end end for i, v in ipairs(t) do t[i].x = t[i][1] t[i].y = t[i][2] end t.index = 0 t.next = function(self) self.index = self.index + 1 local i = self.index if self.index <= #self then return {x = self[i][1], y = self[i][2]} else return nil, 'error: final index passed' end end return t end, } _M.gui = { tcol = { black = '[30m', red = '[31m', green = '[32m', yellow = '[33m', blue = '[34m', cyan = '[35m', magenta = '[36m', white = '[37m' }, col = function(string, new, orig) local orig = orig or 'cyan' return _M.gui.tcol[new]..string.._M.gui.tcol[orig] end, debugprint = function(str) gma.echo(_M.gui.tcol.green..str) end, ConfirmCancellation = function() local trig = _M.gui.confirm("Terminate plugin?", "Press [OK] to return to plugin.\nPress [CANCEL] or X to terminate plugin.") if (not trig) then return true; end end, input = function(title, body, args) local args = args or {}; if type(args) == 'string' then error('Attempt to use deprecated GDF.gui.input arguments. Please update your code.'); elseif type(args) ~= 'table' then error('invalid argument type supplied to GDF.gui.input - argument 3. Table expected, got '..type(args)); end if (args.yesNoCancel) then body = 'y/n'; end; local t; while true do t = gma.textinput(title, body); if ( t and ((t == body) or (#t==0)) and (args.matchEscape) ) then return nil, nil, true; elseif ((not t) or (#t == 0) or (t == body and args.noMatch)) then local trig = _M.gui.confirm("NO INPUT PROVIDED: "..title, "Press [OK] to provide input\n\nPress [CANCEL] or X to terminate plugin."); if (not trig) then return nil, "Plugin terminated by user.", false; end elseif (args.yesNoCancel) then if t:lower() == 'y' then return true; elseif t:lower() == 'n' then return false; else local trig = _M.gui.confirm("INVALID INPUT: "..title, "Input of \"y\" or \"n\" required.\nYour input: \""..t.."\"\n\nPress [OK] to provide input\nPress [CANCEL] or X to terminate plugin."); if (not trig) then return nil, "Plugin terminated by user.", false; end end elseif (args.inputIsNumber) then local start, finish = t:lower():match('(%d+)%s*thru%s*(%d+)'); if (tonumber(t)) then return tonumber(t); elseif (start and finish) then return {tonumber(start), tonumber(finish)}; else local trig = _M.gui.confirm("INVALID INPUT: "..title, "Number input required.\nYour input: "..t.."\n\nPress [OK] to provide input\nPress [CANCEL] or X to terminate plugin."); if (not trig) then return nil, "Plugin terminated by user.", false; end end elseif (args.format) then if t:match(args.format) then return t; else local trig = _M.gui.confirm("INVALID INPUT: "..title, "Input formatting was invalid.\nYour input: "..t.."\n\nPress [OK] to provide input.\nPress [CANCEL] or X to terminate plugin."); if (not trig) then return nil, "Plugin terminated by user.", false; end end else return t; end end end, msgbox = function(title, message_box, message_text) local confirm_method local version = gma.show.getvar('version') if version:find('3.1.2') == 1 then confirm_method = 'textinput' else confirm_method = 'box' end if confirm_method == 'box' then gma.gui.msgbox(title, message_box) elseif confirm_method == 'textinput' then gma.textinput(title, message_text) end end, confirm = function(title, message_box, message_text) local confirm_method local version = gma.show.getvar('version') if version:find('3.1.2') == 1 then confirm_method = 'textinput' else confirm_method = 'box' end if confirm_method == 'box' then return gma.gui.confirm(title, message_box) elseif confirm_method == 'textinput' then local t = gma.textinput(title, message_text) if t then t = true end return t end end, print = function(str) str = tostring(str) for line in str:gmatch('[^\n]+') do gma.echo(line) gma.feedback(line) end end, windowSize = function(ct, maxwidth) local t = {} if ct <= (maxwidth - 1) then t.y = 1 t.x = ct + 1 return t else local testnum = math.ceil(ct/maxwidth) if ((maxwidth * testnum) - 1) < ct then t.y = testnum + 1 else t.y = testnum end local capacity = (maxwidth * t.y - 1) local excess = capacity - ct t.x = maxwidth - math.floor(excess/t.y) return t end end, view_lib = { cmd = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MA xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.malighting.de/grandma2/xml/MA\" xsi:schemaLocation=\"http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.2.2/MA.xsd\" major_vers=\"3\" minor_vers=\"2\" stream_vers=\"2\">\n    <Info datetime=\"2017-06-06T19:11:55\" showfile=\"some shit\" />\n    <View index=\"899\" name=\"CMD/Sys\" display_mask=\"2\">\n        <Widget index=\"0\" type=\"434f4e53\" display_nr=\"1\" y=\"4\" anz_rows=\"4\" anz_cols=\"16\">\n            <Data>\n                <Data>13</Data>\n                <Data>3</Data>\n                <Data>0</Data>\n                <Data>0</Data>\n            </Data>\n        </Widget>\n        <Widget index=\"1\" type=\"44425547\" display_nr=\"1\" has_focus=\"true\" has_scrollfocus=\"true\" anz_rows=\"4\" anz_cols=\"16\">\n            <Data>\n                <Data>0</Data>\n                <Data>0</Data>\n                <Data>0</Data>\n                <Data>0</Data>\n            </Data>\n        </Widget>\n    </View>\n</MA>", sysmon = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MA xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.malighting.de/grandma2/xml/MA\" xsi:schemaLocation=\"http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.3.4/MA.xsd\" major_vers=\"3\" minor_vers=\"3\" stream_vers=\"4\">\n    <Info datetime=\"2018-09-23T12:41:41\" showfile=\"showfile\" />\n    <View index=\"68\" name=\"SYSMON\" display_mask=\"2\">\n        <Widget index=\"0\" type=\"44425547\" display_nr=\"1\" anz_rows=\"8\" anz_cols=\"16\">\n            <Data>\n                <Data>0</Data>\n                <Data>0</Data>\n                <Data>0</Data>\n                <Data>0</Data>\n            </Data>\n        </Widget>\n    </View>\n</MA>", }, callview = function(config) local view_num = config.view local screen = config.screen if type(screen) == 'number' then screen = {screen} end local key = config.key if (not key) or (not _M.gui.view_lib[key]) then return nil, 'error: GDF.gui.callview: invalid key provided' end local cmd_script = _M.gui.view_lib[key] local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.importexport = dir.main..'importexport/' fn = {} fn.temp = [[_templ_view.xml]] file = {} file.temp = dir.importexport..fn.temp local writefile = io.open(file.temp, 'w') writefile:write(cmd_script) writefile:close() local view_orig = _M.poolitem.advanceSpace('View', view_num, 2, 0, 0) local view_temp = view_orig + 1 gma.cmd('Store View '..view_orig..' /screen=all') gma.cmd('SelectDrive 1') gma.cmd('Import "'..fn.temp..'" View '..view_temp) for i = 1, #screen do gma.cmd('View '..view_temp..' /screen='..tostring(screen[i])) end os.remove(file.temp) gma.cmd('Delete View '..view_temp) return view_orig end, cmdview = function(screen) if not screen then screen = 2 end _M.gui.callview{key = 'cmd', screen = {screen}, view = 1} end } _M.dmx = { split_addr = function(str, numindex) if type(str) == 'number' then str = tostring(str) end local index = str:find(':') if not index then index = str:find('[.]') end local t = {} if index then if numindex then t[1] = tonumber(str:sub(1, index-1)) t[2] = tonumber(str:sub(index+1, #str)) return t else t.univ = tonumber(str:sub(1, index-1)) t.ch = tonumber(str:sub(index+1, #str)) end else error('invalid address provided; no separator found') end return t end, merge_addr = function(list, seperator) seperator = seperator or '.' univ = list.univ or list[1] ch = list.ch or list[2] univ, ch = tostring(univ), tostring(ch) while #ch < 3 do ch = '0'..ch end local t = univ..seperator..ch return t end, univ = {}, univ_add = function(self, univ_num) if not _M.csv.objToArray then error('Required function not found: csv.objToArray(str:obj)') end if not _M.gui.superBar then error ('Required module not found: gui.superBar') end pBar_add = _M.gui.superBar:new('Importing Universe '..univ_num) pBar_add:setrange(0, 512) self.univ[univ_num] = _M.csv.objToArray('DmxUniverse '..univ_num..'.*', pBar_add) pBar_add:stop() end, check_space = function(self, addr_start, spaces, flush_cache) if spaces > 512 then spaces = 512; end; if type(addr_start) == 'string' then addr_start = self.split_addr(addr_start) end local addr_current = {univ = addr_start.univ or addr_start[1], ch = addr_start.ch or addr_start[2]} local confirmed = false local t = {ct = 0} while (not confirmed) do if ((not self.univ[addr_current.univ]) or (flush_cache)) then self:univ_add(addr_current.univ) end for i = addr_current.ch, 512 do if #tostring(self.univ[addr_current.univ][i].fixture) == 0 then t.ct = t.ct + 1 if not t.addr then t.addr = {univ = addr_current.univ, ch = addr_current.ch} end if t.ct == spaces then confirmed = true break end addr_current.ch = i + 1 else t.ct = 0 t.addr = nil addr_current.ch = i + 1 end end if not confirmed then addr_current = {univ = addr_current.univ + 1, ch = 1} t.ct = 0 t.addr = nil end end return t.addr end, advanceSpace = function(univ, dmxChanStart, amount) local max = 256; local channel = dmxChanStart; local props = { fixture = 2, channel = 3, attribute = 4, } local t = _M.class.DmxAddress:new() local ct = amount; while (univ <= max) do repeat if _M.get.prop(string.format('DmxUniverse %d.%03d', univ, channel), props.attribute) == '' then ct = ct - 1 if (ct == 0) then t.universe = univ; t.channel = channel - amount + 1; return t; end else ct = amount; end channel = channel + 1; until (channel > 512) ct = amount; channel = 1; univ = univ + 1; end error('GDF error: ran out of DMX universes to check for space.') end } _M.env = { getprog = function() local file = {} file.name = 'tempfile_programmercheck.csv' file.directory = gma.show.getvar('PATH')..'/reports/' file.fullpath = file.directory..file.name gma.cmd('SelectDrive 1') gma.cmd('List Programmer /f=\"'..file.name..'\"') local prog for line in io.lines(file.fullpath) do if line:find('Programmer') == 1 then prog = 'live' elseif line:find('BlindProgrammer') then prog = 'blind' elseif line:find('PreviewProgrammer') then prog = 'preview' end end os.remove(file.fullpath) return prog end, self_id = function(self_table) local unpack = table.unpack local self = self_table[2] local indices = {0, 0} repeat indices = {self:find('%d+', indices[2] + 1)} until indices[2] == #self local self_id = tonumber(self:sub(unpack(indices))) return self_id end, } _M.data = { SaveFile = ST:new{ new = function(self, o) if o.name and o.num then setmetatable(o, self) self.__index = self o:write({}) elseif (not o.name) then return nil, 'ERROR: NO NAME PROVIDED FOR NEW SAVEFILE.' elseif (not o.num) then return nil, 'ERROR: NO NUMBER PROVIDED FOR NEW SAVEFILE.' end return o end, load = function(self, o) if (o.name and _M.get.verify('Plugin \"'..o.name..'\"')) then o.num = _M.get.number('Plugin \"'..o.name..'\"') elseif (o.num and _M.get.verify('Plugin '..o.num)) then o.name = _M.get.label('Plugin '..o.num) else local msg = 'ERROR: NO SAVEFILE FOUND MATCHING PROVIDED NAME OR NUMBER.' gma.echo(_M.gui.tcol.magenta .. msg) gma.echo(_M.gui.tcol.magenta .. 'Provided name: [['..tostring(o.name)..']]') gma.echo(_M.gui.tcol.magenta .. 'Provided number: '..tostring(o.num)) return nil, msg end setmetatable(o, self) self.__index = self return o end, num = 0, name = '', header = '--[============[', footer = '--]============]', write = function(self, data) local script = table.concat({self.header, _M.table.tostring(data), self.footer}, '\n') gma.cmd('Unlock Plugin '..self.num) _M.plugin.write({name = self.name, num = self.num, script = script}, true) gma.cmd('Lock Plugin '..self.num) end, read = function(self) local function s_prep(str) return (str:gsub('(%W)', '%%%1')) end local script = _M.plugin.read(self.num) local script_tbl = script:gsub(s_prep(self.header)..'(.+)'..s_prep(self.footer), '%1') local data = _M.table.fromstring(script_tbl) return data end, delete = function(self) gma.cmd('Unlock Plugin '..self.num) gma.cmd('Delete Plugin '..self.num) end }, getDrive = function() local testPath = function(path, fn, DEBUG) local file_xml = path..fn..'.xml' local file_lua = path..fn..'.lua' local testfile, err = io.open(file_lua) if DEBUG then gma.echo('CHECKING FOR FILE: '..file_lua) end if testfile then testfile:close() os.remove(file_lua) os.remove(file_xml) return path:match('(.*)plugins') else return nil, err end end local alphabet = 'abcdefghijklmnopqrstuvwxyz' local fn = '__FINDME' gma.cmd('Export /nc /o Plugin 1 "'..fn..'"') local fpath = gma.show.getvar('pluginpath')..'/' local file_lua = fpath..fn..'.lua' local file_xml = fpath..fn..'.xml' local testfile, err = io.open(file_lua) if testfile then testfile:close() os.remove(file_lua) os.remove(file_xml) return fpath:match('(.*)plugins') else if gma.show.getvar('hostsubtype'):lower() == 'onpc' then for i = 1, #alphabet do local fpath = alphabet:sub(i,i):upper()..[[:\gma2\plugins\]] local t = testPath(fpath, fn, true) if t then return t end end error('NO FILEPATH FOUND FOR CURRENT DRIVE') else for i = 1, #alphabet do local fpath = { [[/media/sd]]..alphabet:sub(i,i)..[[1/gma2/plugins/]], [[/media/sd]]..alphabet:sub(i,i)..[[/gma2/plugins/]] } for _, v in ipairs(fpath) do local t = testPath(v, fn, true) if t then return t end end end error('NO FILEPATH FOUND FOR CURRENT DRIVE') end end end, getPaths = function(path_ext_array, verbose) local path_ext = '/'; if ( (type(path_ext_array) == 'table') and (path_ext_array[1]) ) then path_ext = '/'..table.concat(path_ext_array, '/')..'/'; end local path_full_ext = '/gma2'..path_ext; local paths = ST:new(); paths:append(gma.show.getvar('path')..path_ext) local alphabet = 'abcdefghijklmnopqrstuvwxyz' for i = 1, #alphabet do if gma.show.getvar('hostsubtype'):lower() == 'onpc' then paths:append(alphabet:sub(i,i):upper()..':'..path_full_ext) else paths:append([[/media/sd]]..alphabet:sub(i,i)..[[1]]..path_full_ext) paths:append([[/media/sd]]..alphabet:sub(i,i)..path_full_ext) end end local conf = ST:new(); for i, path in ipairs(paths) do local fpath = path..'TESTFILE.TEST' if verbose then gma.echo('TESTING: '..fpath); end; local wf, err = io.open(fpath, 'w') if (not err) then wf:close() os.remove(fpath); conf:append(path) end end return conf; end, parseColon = function(info_raw) local t = {} for i in info_raw:gmatch('.-%:.-[\n]') do local k, v = i:match('%s*([^\n]+)%s*%:%s*([^\n]+)[%s\n]*') if k and v then t[k] = v end end return t end, trunc = function(num, modulus) return (num - num%modulus) end, round = function(num, modulus) local trunc = _M.data.trunc(num, modulus) local under = math.abs(trunc - num) local over = math.abs((trunc + modulus) - num) if under < over then return trunc else return (trunc + modulus) end end, sr_ct = 1, setrange = function(config) local l = _M.data if config.start then l.sr_ct = config.start end if (not config.loops) then local start = l.sr_ct local finish = l.sr_ct + config.size - 1 l.sr_ct = l.sr_ct + config.size if config.direct then return start, finish else return {start = start, finish = finish} end elseif config.loops then local results = {} for i = 1, config.loops do results[i] = l.sr_ct l.sr_ct = l.sr_ct + range end return unpack(results) end end, GDpath = function(...) GD = GD or {} local path = GD local path_str = 'GD' local tbl = {...} if type(tbl[1]) == 'table' then tbl = tbl[1]; end; for i, v in ipairs(tbl) do if not path[v] then path[v] = {} end path = path[v] if type(v) == 'number' then path_str = path_str..'['..v..']' elseif type(v) == 'string' then path_str = path_str..'.'..v end end gma.echo(_M.gui.tcol.blue..'PATH CREATED: '..path_str) return path end, BinaryToHex = function(bin) local tbl = {} for i = 1, #bin do table.insert(tbl, string.format("%.2X", string.byte(bin:sub(i,i)))) end return table.concat(tbl, '') end, HexToBinary = function(hex_str) local tbl = {} for i = 1, #hex_str, 2 do table.insert(tbl, tonumber('0x'..hex_str:sub(i, i+1))) end return string.char(unpack(tbl)) end, BinaryToInt = function(binaryStr) local binaryValues = _M.data._binaryValues; binaryStr = binaryStr:reverse(); local int = 0; for i = 1, #binaryStr do if binaryStr:sub(i, i) == '1' then int = int + binaryValues[i]; end; end return tonumber(string.format('%d', int)); end, IntToBinary = function(int, bitCount) local binaryValues = _M.data._binaryValues; local bitCount = bitCount or 8; local bits = {} for i = 1, bitCount do bits[i] = '0'; end; local index = 1; while (index <= #bits) do if binaryValues[index] >= int then break; else index = index + 1; end end for i = index, 1, -1 do if (binaryValues[i] <= int) then bits[i] = '1'; int = int - binaryValues[i]; end end return table.concat(bits):reverse(); end, BinAnd = function(binStr1, binStr2) if (#binStr1 ~= #binStr2) then error('unequal binary strings provided to BinAnd(binStr1, binStr2)'); end local t = {} for i = 1, #binStr1 do if binStr1:sub(i, i) == '1' and binStr2:sub(i, i) == '1' then t[i] = '1'; else t[i] = '0'; end; end return table.concat(t); end, BinOr = function(binStr1, binStr2) if (#binStr1 ~= #binStr2) then error('unequal binary strings provided to BinOr(binStr1, binStr2)'); end local t = {} for i = 1, #binStr1 do if binStr1:sub(i, i) == '1' or binStr2:sub(i, i) == '1' then t[i] = '1'; else t[i] = '0'; end; end return table.concat(t); end, BinInvert = function(binStr) local ref = { ['1'] = '0', ['0'] = '1', }; return (binStr:gsub("[0-1]", function(char) return ref[char] or char end)) end, StripExtraQuotes = function(str) if (type(str) == 'string') then local match = str:match("^%s*\"(.*)\"%s*$"); if (match) then return match; else return str; end; else return str; end end, format = function(str, opt) if opt:lower() == 'info' then str = str:gsub([["]], [[&quot;]]); str = str:gsub([[<]], [[&lt;]]); str = str:gsub([[>]], [[&gt;]]); str = str:gsub('%%', '%%%%'); return str; end end, } _M.data._binaryValues = {} for i = 1, 64 do _M.data._binaryValues[i] = 2^(i-1); end _M.table = { tostring = function(tbl) local function exportstring( s ) return string.format("%q", s) end local charS,charE = "   ","\n" local build_t,err = _M.class.SuperTable:new() local tables,lookup = { tbl },{ [tbl] = 1 } build_t:append( "return {"..charE ) for idx,t in ipairs(tables) do build_t:append( "-- Table: {"..idx.."}"..charE ) build_t:append( "{"..charE ) local thandled = {} for i,v in ipairs( t ) do thandled[i] = true local stype = type( v ) if stype == "table" then if (not lookup[v]) then table.insert( tables, v ) lookup[v] = #tables end build_t:append( charS.."{"..lookup[v].."},"..charE ) elseif stype == "string" then build_t:append( charS..exportstring( v )..","..charE ) elseif (stype == "number") or (stype == "boolean") then build_t:append( charS..tostring( v )..","..charE ) end end for i,v in pairs( t ) do if (not thandled[i]) then local str = "" local stype = type( i ) if stype == "table" then if not lookup[i] then table.insert( tables,i ) lookup[i] = #tables end str = charS.."[{"..lookup[i].."}]=" elseif (stype == "string") then str = charS.."["..exportstring( i ).."]=" elseif (stype == "number") or (stype == "boolean") then str = charS.."["..tostring( i ).."]=" elseif stype == "" then end if str ~= "" then stype = type( v ) if stype == "table" then if not lookup[v] then table.insert( tables,v ) lookup[v] = #tables end build_t:append( str.."{"..lookup[v].."},"..charE ) elseif stype == "string" then build_t:append( str..exportstring( v )..","..charE ) elseif (stype == "number") or (stype == "boolean") then build_t:append( str..tostring( v )..","..charE ) else gma.echo('unhandled value: '..v) end end end end build_t:append( "},"..charE ) end build_t:append("}") return build_t:concat() end, fromstring = function(tbl_string) local ftables,err = load(tbl_string) if err then return _,err end local tables = ftables() if ftables == nil then return {} end for idx = 1,#tables do local tolinki = {} for i,v in pairs( tables[idx] ) do if type( v ) == "table" then tables[idx][i] = tables[v[1]] end if type( i ) == "table" and tables[i[1]] then table.insert( tolinki,{ i,tables[i[1]] } ) end end for _,v in ipairs( tolinki ) do tables[idx][v[2]],tables[idx][v[1]] = tables[idx][v[1]],nil end end return tables[1] end, buildpath = function(master, list) local dir_c = master for _, v in ipairs(list) do if not dir_c[v] then dir_c[v] = {} dir_c = dir_c[v] end end return dir_c end, keyswap = function(tbl) local t = ST:new() for k, _ in pairs(tbl) do t:append(k) end return t end, keyset = function(tbl, opt) local t = {}; if ((opt) and (opt.keyIsValue)) then for k, v in pairs(tbl) do t[v] = k; end else for k, v in pairs(tbl) do t[v] = true; end end return t end, keycheck = function(tbl, keys_tbl) for _, v in ipairs(keys_tbl) do if type(tbl[v]) == 'nil' then return false end end return true end, copy = function(obj) if type(obj) ~= 'table' then return obj end local t = {} for k, v in pairs(obj) do t[k] = _M.table.copy(v) end return t end, matchLength = function(...) local tables = {...} local lengths = {} local max = 0 local adj = 0 for i, v in ipairs(tables) do lengths[i] = #v if #v > max then max = #v adj = adj + 1 end end if adj > 1 then for i = 1, #tables do if #tables[i] < max then local pos = 1 for j = #tables[i] + 1, max do tables[i][j] = tables[i][pos] if pos == #tables[i] then pos = 1 else pos = pos + 1 end end end end end end } _M.xml = { sub = function(script, replacementTable) for k, v in pairs(replacementTable) do script = script:gsub('<!'..k..'>', v) end return script end, format = function(str) if type(str) ~= 'string' then return tostring(str); end; str = str:gsub([["]], [[&quot;]]); str = str:gsub([[']], [[&apos;]]); str = str:gsub([[<]], [[&lt;]]); str = str:gsub([[>]], [[&gt;]]); str = str:gsub('%%', '%%%%'); return str; end, ConvertToAttributeString = function(pairsList) if (not pairsList) then return ''; end; local strTbl = {}; for key, value in pairs(pairsList) do table.insert(strTbl, string.format('%s="%s"', key, _M.xml.format(value))); end if #strTbl == 0 then return ''; else return ' ' .. table.concat(strTbl, ' '); end; end, extract_vartags = function(script) local t = {} local indices = {0, 0} local remaining = true while remaining do indices = {script:find('<![^-].->', (indices[2] + 1))} if not indices[2] then break elseif indices[2] == #script then remaining = false end t[#t+1] = script:sub(indices[1] + 2, indices[2] - 1) end return t end } _M.csv = { lineToArray = function(str) local t = {} local indices = {1, 1} local remaining = true local restart = 1 while remaining == true do local pt = {str:find(',', restart)} if pt[1] then t[#t+1] = str:sub(restart, pt[1]-1) restart = pt[2] + 1 else remaining = false t[#t+1] = str:sub(restart, str[-1]) end end return t end, subheaderToArray = function(str, header) local t = {} local indices = {1, 1} local remaining = true local restart = 1 local index = 1 while remaining == true do local pt = {str:find(',', restart)} if pt[1] then t[header[index]] = str:sub(restart, pt[1]-1) restart = pt[2] + 1 index = index + 1 else remaining = false t[header[index]] = str:sub(restart, str[-1]) end end return t end, fileToArray = function(file, pBar) local header = {} local results = ST:new{} local match_pattern = '' local key_ct = 0; local firstLine = true for line in io.lines(file) do if firstLine then local key_ct = 0; header = _M.csv.lineToArray(line) for k, v in pairs(header) do header[k] = v:lower() key_ct = key_ct + 1 end firstLine = false match_pattern = '.-'..string.rep(',.-', key_ct-1) else if line:match(match_pattern) then results:append(_M.csv.subheaderToArray(line, header)) end end if pBar then pBar:set(1, true) end end return results end, objToArray = function(obj, pBar) local dir = {temp = gma.show.getvar('PATH')..'/reports/'} local fn = {temp = 'export_csvobject'.._M.internal.counter()..'.csv'} local file = {temp = dir.temp..fn.temp} gma.cmd('SelectDrive 1') if obj then gma.cmd('List '..obj..' /f=\"'..fn.temp..'\"') else gma.cmd('List /f=\"'..fn.temp..'\"') end local t local test = io.open(file.temp) if test then test:close() t = _M.csv.fileToArray(file.temp, pBar) os.remove(file.temp) else t = {} end return t end, write_table = function(list) local t = '' for i = 1, #list do t = t..table.concat(list[i], ',')..'\n' end return t end, file_cleanup = function() local dir = gma.show.getvar('PATH')..'/reports/' for i = 1, 250 do local _, err = os.remove(string.format('%stempfile_getroot%d.csv', dir, i)) end end } _M.lua = { sub = function(script, replacementTable) local function s_prep(str) return (str:gsub('(%W)', '%%%1')) end local function literal_bracket(str) local tbl = {} for match in str:gmatch('%[[=]*%[') do tbl[#match-2] = true end local x = 0 while true do if not tbl[x] then break end x = x + 1 end print(x) local rep = string.rep('=', x) return '['..rep..'[', ']'..rep..']' end local end_tag = '<!end-replacements>' end_tag = s_prep(end_tag) local head, body = script:match('(.-'..end_tag..')(.*)') for k, v in pairs(replacementTable) do local value = v if type(v) == 'string' then value = string.format("%q", v) elseif type(v) == 'table' then if v[2] and (type(v[1]) == 'string') then local b = {literal_bracket(v[1])} value = b[1]..v[1]..b[2] else value = v[1] end end head = head:gsub('<!'..k..'>', value) end return head..body end } _M.get = { handle = gma.show.getobj.handle , class = function(obj, silent) if (not silent) then gma.echo('ignore potential "error: returns string:classname" message below') end return gma.show.getobj.class(_M.get.handle(obj)) end , label = function(obj) return gma.show.getobj.label(_M.get.handle(obj)) end , name = function(obj) local t = gma.show.getobj.name(_M.get.handle(obj)) if not t then t = gma.show.getobj.label(_M.get.handle(obj)) end return t end , verify = function(obj, silent) if (not silent) then gma.echo('ignore potential "error: returns bool:result" message below') end return not not _M.get.handle(obj) end , amount = function(obj) return gma.show.getobj.amount(_M.get.handle(obj)) end , parent = function(obj) return gma.show.getobj.amount(_M.get.handle(obj)) end , number = function(obj) return gma.show.getobj.number(_M.get.handle(obj)) end , index = function(obj) return gma.show.getobj.index(_M.get.handle(obj)) end , child = function(obj, index) return gma.show.getobj.child(_M.get.handle(obj), index) end, prop_amount = function(obj) return gma.show.property.amount(_M.get.handle(obj)) end, prop_name = function(obj, index) return gma.show.property.name(_M.get.handle(obj), index) end, prop = function(obj, ref) return gma.show.property.get(_M.get.handle(obj), ref) end, appearance = function(obj) local l_dir = _M.get function math.round(num) if num - num%1 < 0.5 then return math.floor(num) else return math.ceil(num) end end function match(a, b) if a == b then return true; elseif type(a) == 'string' and type(b) == 'string' then if a:lower():find(b:lower()) or b:lower():find(a:lower()) then return true else return false end else return false end end function table.find(t, target, i, j) local i = i or 1 local j = j or #t for n = i, j do if match(t[n], target) == true then return n end end return nil end local folder_options = {'effects', 'macros', 'masks', 'matricks', 'user_profile', 'plugins'} local poolType local t = table.find(folder_options, obj:lower():sub(1,4)) if t then poolType = folder_options[t] else poolType = 'importexport' end gma.cmd('SelectDrive 1') local fn = {} fn.temp = '_tempfile_getappearance'.._M.internal.counter() local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.obj = dir.main..poolType..'/' local file = {} file.xml = dir.obj..fn.temp..'.xml' file.lua = dir.obj..fn.temp..'.lua' local verified = _M.get.verify(obj) if not verified then return nil, 'Error: object does not exist.' end gma.cmd('Export '..obj..' \"'..fn.temp..'\"') local t = {} for line in io.lines(file.xml) do t[#t + 1] = line end os.remove(file.xml) if poolType == 'plugins' then os.remove(file.lua) end local colorHex for i = 1, #t do if t[i]:find('Appearance Color') then local indices while true do local j = j indices = {t[i]:find('\"%x+\"')} if indices[2]-indices[1]-1 == 6 then indices[1], indices[2] = indices[1] + 1, indices[2] - 1 break elseif indices then j = indices[2] else gma.echo('error: appearance function triggered, not found') return nil end end colorHex = t[i]:sub(indices[1], indices[2]) break end end local colors = ST:new{} if colorHex then colors.hex = {colorHex:sub(1,2),colorHex:sub(3,4),colorHex:sub(5,6)} colors.percent, colors.decimal = {}, {} for i = 1, 3 do colors.decimal[i] = tonumber('0x'..colors.hex[i]) colors.percent[i] = math.round(colors.decimal[i]/2.55) end colors.str = { hex = colorHex, appearance = '/r='..colors.percent[1]..' /g='..colors.percent[2]..' /b='..colors.percent[3] } else return nil, 'object appearance not assigned' end return colors end, list = function(object) local location = 'reports' local fn = {temp = 'temp_generatepoolobject'.._M.internal.counter()..'.csv'} local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.temp = dir.main..location..'/' local file = {temp = dir.temp..fn.temp} gma.cmd('SelectDrive 1') gma.cmd('List '..object..' /f="'..fn.temp..'"') local readFile = io.open(file.temp, 'r') local script = ''; if readFile then script = readFile:read('*a') readFile:close() os.remove(file.temp) end return script end, execlist = function(timecode) local list = _M.csv.objToArray('Timecode '..timecode..'.*') local e_list = ST:new{} for i, v in ipairs(list) do e_list[i] = v.exec:match('(%d+%.%d+)$') end e_list.numstr = e_list:concat(' + ') e_list.str = 'Executor '..e_list.numstr return e_list end, seqlist = function(execs) local s = execs:lower(); if ( (not s:find('^%s*page')) and (not s:find('^%s*executor')) ) then execs = 'Executor '..execs elseif ( (s:find('^%s*page')) and (not s:find('^%s*executor')) ) then execs = execs .. ' Executor *' end local scr = _M.get.list(execs) local seq_list = {} for match in scr:gmatch('Sequence=Seq %d+') do seq_list[match:match('%d+')] = true end seq_list = _M.table.keyswap(seq_list) seq_list.numstr = seq_list:concat(' + ') seq_list.str = 'Sequence '..seq_list:concat(' + ') return seq_list end, script = function(object, args) local args = args or {}; local debug_stream = args.debug or _M.class.DebugStream:new(); debug_stream:setIndent(1, true); local location = args.alternate_location or 'importexport' local fn = {temp = 'temp_generatepoolobject'.._M.internal.counter()..'.xml'}; local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.temp = dir.main..location..'/' local file = {temp = dir.temp..fn.temp} gma.cmd('SelectDrive 1') debug_stream:writeLine(string.format('Current memory usage: %.3fKB', collectgarbage("count"))) debug_stream:startLine('Exporting '..object..' for XML script at '..file.temp..'...'); gma.sleep(0.05); gma.cmd('Export '..object..' "'..fn.temp..'" /nc') debug_stream:write('OK\n'); local readfile = io.open(file.temp, 'r'); if (not readfile) then return nil, 'NO OBJECT'; end; local script = readfile:read('*a'); readfile:close(); os.remove(file.temp) local test, err = io.open(file.temp, 'r'); if (test) then test:close(); debug_stream:writeLine('WARNING: '..file.temp..' COULD NOT BE DELETED.'); elseif (err) then debug_stream:writeLine('Temp file deleted'); end debug_stream:setIndent(-1, true); return script end, group = function(grpNum) gma.cmd('SelectDrive 1') local file = {} file.name = 'tempfile.xml' file.directory = gma.show.getvar('PATH')..'/'..'importexport'..'/' file.fullpath = file.directory..file.name gma.cmd('Export Group ' .. grpNum .. ' \"' .. file.name .. '\"') local t = {} local readFile = io.open(file.fullpath, 'r') local script = readFile:read('*a') readFile:close() os.remove(file.fullpath) local groupList = {fixt=ST:new(), chan=ST:new()} for match in script:gmatch('<Subfixture (.-) />') do local ch = match:match('cha_id="(%d+)"') local fixt = match:match('fix_id="(%d+)"') local sub = match:match('sub_index="(%d+)"') local t = {} if ch then t[1] = tonumber(ch) else t[1] = tonumber(fixt) end if sub then t[2] = sub t.full = string.format('%d.%d', t[1], t[2]) else t.full = string.format('%d', t[1]) end if (ch) then groupList.chan:append(t) else groupList.fixt:append(t) end end return groupList end, final = function(obj, dist) local gap = {start=0, size=0} local t = _M.csv.objToArray(obj..' Thru') local final = tonumber(t[#t]['no.']) local last_num = 1; for i, v in ipairs(t) do local num = tonumber(t[i]['no.']) if num - last_num >= gap.size then gap.start = last_num+1; gap.size = num - last_num - 1; end last_num = num; end if ((10000-final) < gap.size) then return gap.start, gap.start + gap.size - 1 else return final, 10000 end end, listFinal = function(base) for i = 1, math.huge do if not _M.get.verify(base..i) then return i-1; end; end end, numlist = function(obj) local script = _M.get.list(obj) local t = ST:new{} if (#script == 0) then return t; end; local header_str, body = script:match('^(.-\n)(.*)') local headers = {} for match in header_str:gmatch('([^,]+)') do match = match:gsub('\n', ''):lower() headers[#headers+1] = match if (match=='no.') or (match=='no') then break; end; end local linestart = body:match('^(%a+)%s*[%d%.]+%s*,') local ls_pattern = linestart..'%s*[%d%.]+%s*'..string.rep(',.-', (#headers-1))..',([%d%.]+)' for match in body:gmatch(ls_pattern) do t:append(match) end return t end, info = function(object) return _M.get.prop(object, 'Info') end, rootnum_list = ST:new(), rootnum = function(str, objnum) local unpack = table.unpack str = str:lower() if not _M.get.rootnum_list[str] then local temp = {} temp.fn = 'tempfile_getroot'.._M.internal.counter()..'.csv' temp.dir = gma.show.getvar('PATH')..'/reports/' temp.file = temp.dir..temp.fn gma.cmd('SelectDrive 1') gma.cmd('List /f=\"'..temp.fn..'\"') local line_locate = 0 for line in io.lines(temp.file) do if line:lower():find(str) then line_locate = tonumber(line:sub(unpack({line:find('%d+')}))) break end end local _, err = os.remove(temp.file) local global = false if line_locate and line_locate ~= 0 then gma.cmd('CD '..line_locate) gma.cmd('List /f=\"'..temp.fn..'\"') for line in io.lines(temp.file) do if line:lower():find('global') then global = true break end end end local _, err = os.remove(temp.file) gma.cmd('CD /') if line_locate == 0 then return false, 'string not found' else local t = ST:new() if global then t = {line_locate, 1} else t = {line_locate} end _M.get.rootnum_list[str] = t end end local t1 = _M.get.rootnum_list[str] local t2 = ST:new() for _, v in ipairs(t1) do t2:append(v) end t2:append(tonumber(objnum)) return t2 end, } _M.set = { info = function(object, info, alternate_location) local location = alternate_location or 'importexport' local fn = {temp = 'temp_infoinject'.._M.internal.counter()..'.xml'} local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.temp = dir.main..location..'/' local file = {temp = dir.temp..fn.temp} gma.cmd('SelectDrive 1') gma.cmd('Unlock '..object) gma.cmd('Assign '..object..' /info="<SET>"') gma.cmd('Export '..object..' "'..fn.temp..'" /nc') local readFile = io.open(file.temp, 'r') local script_src = readFile:read('*a') readFile:close() info = info:gsub([["]], [[&quot;]]); info = info:gsub([[<]], [[&lt;]]); info = info:gsub([[>]], [[&gt;]]); info = info:gsub('%%', '%%%%'); local script_output = script_src:gsub('&lt;SET&gt;', info) local writefile = io.open(file.temp, 'w') writefile:write(script_output) writefile:close() gma.cmd('Import "'..fn.temp..'" '..object..' /nc') os.remove(file.temp) end, } _M.poolitem = { generate = function(object, script, args) local args = args or {}; local dStream = args.debugStream or _M.class.DebugStream:new(); dStream:setIndent(1, true); local location = args.alternateLocation or 'importexport' local fn = {temp = 'temp_generatepoolobject'.._M.internal.counter()..'.xml'} local dir = {} dir.main = gma.show.getvar('PATH')..'/' dir.temp = dir.main..location..'/' local file = {temp = dir.temp..fn.temp} dStream:startLineI('Writing script to %s...', file.temp); local writefile, err = io.open(file.temp, 'w') if (err) then dStream:write('FAILED.\n') dStream:writeLine('Error message: %s', tostring(err)) return nil, err; end writefile:write(script); writefile:close(); dStream:write('done.\n') dStream:cmd('SelectDrive 1') local overwriteStr = '' if args.forceOverwrite then overwriteStr = ' /nc'; end; dStream:cmd('Import%s "%s" %s', overwriteStr, fn.temp, object); if args.keepScript then dStream:echo('file not deleted: %s', fn.temp) else os.remove(file.temp); end; dStream:setIndent(-1, true); end, checkSpace = function(poolType, start, length, exceptions) local finish = start + length - 1 local emptyStatus = true local failpoint local exceptions = exceptions or {} for i = start, finish do local obj_str = poolType..' '..tostring(i) if _M.get.verify(obj_str) then local exc = false for _, v in ipairs(exceptions) do if _M.get.name(obj_str):find(v) then exc = true break end end if not exc then emptyStatus = false failpoint = i break end end end return emptyStatus, failpoint end, advanceSpace = function(poolType, start, length, arg1, arg2, arg3) local pad_before, pad_after, exceptions, debug_stream if ((arg1) and (type(arg1) ~= 'table')) then pad_before = arg1; pad_after = arg2; exceptions = arg3; elseif ((arg1) and (type(arg1) == 'table')) then if (arg1.pad) then pad_before, pad_after = arg1.pad[1], arg1.pad[2]; end; exceptions = arg1.exceptions; debug_stream = arg1.debug end start, length = tonumber(start), tonumber(length) local pad_before = pad_before or 0 local pad_after = pad_after or 0 pad_before, pad_after = math.abs(pad_before), math.abs(pad_after) local length_actual = length + pad_before + pad_after local exceptions = exceptions or {} if (not debug_stream) then debug_stream = _M.class.DebugStream:new() end; debug_stream:setIndent(1, true) debug_stream:writeLine('Checking for '..poolType..' space:') debug_stream:writeLine('Start: '..start..'; Length:'..length..'; Pads: '..pad_before..', '..pad_after) if (#exceptions > 0) then debug_stream:writeLine('Exceptions: '..table.concat(exceptions, ', ')) end; debug_stream:setIndent(1, true); local finalStart = start; local preroll = 0; local start_border = true; while true do if (start_border) then if (finalStart - pad_before > 0) then start_border = false; preroll = pad_before; length_actual = length + pad_before + pad_after; else preroll = finalStart - 1; length_actual = length + preroll + pad_after; end end local test, failpoint = _M.poolitem.checkSpace(poolType, finalStart, length_actual, exceptions) if failpoint then finalStart = failpoint + 1; debug_stream:writeLine('Restarting check at '..finalStart); else break end end finalStart = finalStart + preroll debug_stream:setIndent(-1, true); debug_stream:writeLine('OUTPUT: '..poolType..' '..tonumber(finalStart)) debug_stream:setIndent(-1, true) return finalStart end, infoMatch = function(poolType, header, pbar, opt) local verbose; if (opt and opt.verbose) then verbose=true; end; local list; if (opt and opt.list) then list=true; end; local match_all; if (opt and opt.match_all) then match_all=true; end; if verbose then gma.echo('verbose: '..tostring(verbose)) gma.echo('list: '..tostring(list)) gma.echo('match_all: '..tostring(match_all)) end local header = '^%s*'..header:lower() local MATCH = ST:new{} local nums = ST:new{} local prefix = poolType if ( not (poolType:lower():find('%d+%.%s*$')) ) then prefix = prefix..' '; end; local is_preset; if poolType:lower():find('^%s*preset') then is_preset = true; end; if (not list) then nums = _M.get.numlist(prefix..'*') if ((not nums) or (#nums==0)) then if (pbar) then pbar:stop(); end; return {}; end; if (is_preset) then for i, v in ipairs(nums) do nums[i] = v:match('%d+%.(%d+)') end end local final = nums[#nums] if (pbar) then pbar:setrange(0, final); pbar:set(0); end else for i = 1, math.huge do if ( not _M.get.verify(prefix..' '..tostring(i)) ) then break; else nums:append(i); end; end end if pbar then pbar:settext('Matching Obj Type: '..prefix); end; if verbose then echo('#nums: '..#nums); end; for _, v in ipairs(nums) do local obj = prefix..v; if verbose then echo('CHECKING OBJECT: '..obj); end; local info = _M.get.prop(obj, 'Info'):lower() if verbose then echo('INFO FOUND: '..info) end if info:find(header) then if (not match_all) then local key = info:match('id:%s*([%w%_]+)') if ((opt.num_keys) and (tonumber(key))) then key = tonumber(key); end; if key then if pbar then pbar:set(1, true); end; local val = info:match('val:%s*([%d%.]+)') if val then val = tonumber(val) if (not MATCH[key]) then MATCH[key] = _M.class.ObjSet:new{} end MATCH[key][val] = v else MATCH[key] = v end end else MATCH:append(v) end end end if pbar then pbar:stop(); end; return MATCH; end, formatID = function(id) if (type(id) == 'string') then id = _M.data.StripExtraQuotes(id); id = string.format('\"%s\"', id); else id = tostring(id); end; return id; end, } _M.plugin = { write = function(config, force_overwrite) local EOLnum if config.EOL then EOLnum = 1 else EOLnum = 0 end local plugin = {} plugin.name = 'tempFile_createPlugin' plugin.directory = gma.show.getvar('PLUGINPATH')..'/' plugin.fullpathLUA = plugin.directory..plugin.name..'.lua' plugin.fullpathXML = plugin.directory..plugin.name..'.xml' local xmlText = string.format("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MA xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.malighting.de/grandma2/xml/MA\" xsi:schemaLocation=\"http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.2.2/MA.xsd\" major_vers=\"3\" minor_vers=\"2\" stream_vers=\"2\">\n    <Info datetime=\"2016-09-26T20:40:54\" showfile=\"dummyfile\" />\n    <Plugin index=\"1\" execute_on_load=\"%d\" name=\"%s\" luafile=\"%s.lua\" />\n</MA>" , EOLnum, config.name, plugin.name) local fileXML = assert(io.open(plugin.fullpathXML, 'w')) fileXML:write(xmlText) fileXML:close() local fileLUA = assert(io.open(plugin.fullpathLUA, 'w')) fileLUA:write(config.script) fileLUA:close() local importcmd = 'Import \"'..plugin.name..'\" Plugin '..tostring(config.num) if force_overwrite then importcmd = importcmd..' /o /nc' end gma.cmd('SelectDrive 1') gma.cmd(importcmd) os.remove(plugin.fullpathXML) os.remove(plugin.fullpathLUA) end, read = function(num) local fn = {} fn.temp = '_plugintemp'.._M.internal.counter() local dir = {} dir.plugins = gma.show.getvar('PLUGINPATH')..'/' local file = {} file.xml = dir.plugins..fn.temp..'.xml' file.lua = dir.plugins..fn.temp..'.lua' gma.cmd('SelectDrive 1') gma.cmd('Export Plugin '..num..' \"'..fn.temp..'\"') local readfile = io.open(file.lua, 'r') local script = readfile:read('*a') readfile:close() local XMLread = io.open(file.xml, 'r') local XMLscript = XMLread:read('*a') XMLread:close() local EOL = XMLscript:match('execute_on_load=\"(%d)\"') if tonumber(EOL) == 1 then EOL = true else EOL = false end os.remove(file.xml) os.remove(file.lua) return script, EOL end, revExport = function(config) local num = config.num local name = config.name or _M.get.label('Plugin '..num) or 'Plugin '..num local dir = {plugin = gma.show.getvar('PLUGINPATH')..'/'} local file = { lua = dir.plugin..name..'.lua', xml = dir.plugin..name..'.xml' } gma.cmd('SelectDrive 1') gma.cmd('Export Plugin '..num..' "'..name..'" /nc') local readfile = assert(io.open(file.xml, 'r')) local script = readfile:read('*a') readfile:close() script = script:gsub([[major_vers="%d+" minor_vers="%d+" stream_vers="%d+"]], [[major_vers="3" minor_vers="0" stream_vers="0"]]) local writefile = assert(io.open(file.xml, 'w')) writefile:write(script) writefile:close() if (gma.show.getvar('hostsubtype'):lower() == 'onpc') and (config.open) then cmd = 'Explorer "'..dir.plugin..'"' cmd = cmd:gsub('/', '\\') os.execute(cmd) gma.echo(cmd) end end, } _M.exec = { advance = function(page, exec, ct, minExec) local errMsg = {minExec = 'Error: minExec set too high for desired executor count'} local starts = {1, 101, 201} local limits = {100, 199, 220} local function canFit(exec, ct) if (exec > limits[#limits]) then return false; end; for i = 1, #limits do if ( (exec >= starts[i]) and ((exec+ct-1) <= limits[i]) ) then return true; end end return false; end local page = tonumber(page); local exec = tonumber(exec); local ct = ct or 1; ct = tonumber(ct) local minExec = minExec if (not minExec) then for i, startPoint in ipairs(starts) do if (exec >= startPoint) then minExec = startPoint; end; end end if (not canFit(minExec, ct)) then return nil, errMsg.minExec; end local pageCurrent = tonumber(page) local execCurrent = tonumber(exec) repeat local pass = true; if canFit(execCurrent, ct) then for exec = execCurrent, execCurrent+ct-1 do if _M.exec.getstatus(pageCurrent, exec) ~= 'EMPTY' then pass = false; execCurrent = exec + 1; break; end end else pass = false; pageCurrent = pageCurrent + 1 execCurrent = minExec end until (pass) local t = _M.class.Executor:new{ page = pageCurrent, exec = execCurrent, str = tostring(pageCurrent)..'.'..tostring(execCurrent) } return t end, getstatus = function(page, executor) local obj = 'Executor '..page..'.'..executor; local slotStatus = _M.get.handle(obj); if slotStatus then if _M.get.handle(obj..' Cue') then local c = _M.get.class(obj..' Cue'); if c == "CMD_SEQUENCE" then return 'OFF' elseif c == "CMD_CUE" then return 'ON' end else if _M.get.label(obj) then return 'NON-SEQ' else if (_M.get.prop(obj, 'name') == 'Exec') then return 'EMPTY'; else return 'NON-SEQ'; end end end else return 'EMPTY' end end, propstr_assign = function(str) local props = {} local indices = {1, 1} while indices[2] < #str do indices = {str:find('%s[^=]+[=][^,]+', indices[2])} if (not indices[1]) then break end indices[1] = indices[1] + 1 local t = str:sub(unpack(indices)) local key = t:sub(t:find('[^=]+')) local indices2 = {t:find('[=][^=]+')} indices2[1] = indices2[1] + 1 local value = t:sub(unpack(indices2)) props[key] = value end local str_props = '' for k, v in pairs(props) do if v:find('%s') then v = '\"'..v..'\"' end str_props = str_props..[[ /]]..k..[[=]]..v end return str_props end } _M.net = { getsessioninfo = function() local t = ST:new{ type = gma.network.gethosttype(), subtype = gma.network.gethostsubtype(), primary_ip = gma.network.getprimaryip(), secondary_ip = gma.network.getsecondaryip(), status = gma.network.getstatus(), sessionnum = gma.network.getsessionnumber(), sessionname = gma.network.getsessionname(), slot = gma.network.getslot(), } return t end, gethostdata = gma.network.gethostdata, } _M.class.superTable = _M.class.SuperTable _M.class.queue = _M.class.Queue _M.class.macro = _M.class.Macro _M.gui.superBar = _M.class.ProgressBar _M.class.Layout = _M.lo.layout

 return _M ]==========];local GDF = load(GDFstr)(); local class = GDF.class local lo = GDF.lo local gui = GDF.gui local dmx = GDF.dmx local env = GDF.env local data = GDF.data local tbl = GDF.table local xml = GDF.xml local csv = GDF.csv local lua = GDF.lua local get = GDF.get local set = GDF.set local pi = GDF.poolitem local plugin = GDF.plugin local exec = GDF.exec local imgpack= GDF.img local net = GDF.net local self_table = {...} data.GDpath{'internal'} local SCRIPTS = {}; local gma = gma local ST = class.superTable local print = gui.print local text = gma.textinput local function cmd(...) gma.cmd(string.format(...)) end local function echo(...) gma.echo(string.format(...)) end local function feedback(...) gma.feedback(string.format(...)) end local pBars = ST:new() local cleanup_cmd = ST:new() install_log = ST:new(); MIDI = {} MIDI.data = ST:new{ [0] = {mult = CONFIG.ATTRIB_ROTATE_MULT}, [1] = {mult = CONFIG.ATTRIB_ROTATE_MULT}, [2] = {mult = CONFIG.ATTRIB_ROTATE_MULT}, [3] = {mult = CONFIG.ATTRIB_ROTATE_MULT}, [4] = {mult = CONFIG.SCREEN_ROTATE_MULT}, [5] = {mult = CONFIG.SCREEN_ROTATE_MULT}, [6] = {mult = CONFIG.SCREEN_ROTATE_MULT}, [7] = {mult = CONFIG.SCREEN_ROTATE_MULT}, [8] = {mult = CONFIG.SCREEN_ROTATE_MULT}, [9] = {mult = CONFIG.SCREEN_ROTATE_MULT}, } MIDI.rotate = function(encoder_num, amount) gma.canbus.encoder(encoder_num, (amount*MIDI.data[encoder_num].mult), nil) end MIDI.click = function(encoder_num, status) gma.canbus.encoder(encoder_num, 0, status) end MIDI.wheel = function(amount) gma.canbus.wheel(amount*CONFIG.DIMMER_WHEEL_MULT) end local PLUGIN_COMPLETE = false; local function Main() local m = class.MsgBox:new('Install MIDI Encoder Remotes?') m:append("Existing MIDI Encoder Remotes will be removed if present.") m:append('') m:append("Proceed?") if not (m:confirm()) then goto EOF; end; local type = 'Remote 2.' local capture = ST:new(); for i = 1, math.huge do local obj = type..tostring(i); if ( not get.verify(obj) ) then break; elseif get.prop(obj, 'Info'):lower() == 'midi_enc' then capture:append(i); end end if #capture > 1 then local c = string.format('Delete /nc %s %s', type, capture:concat(' + ')) install_log:append('EXECUTING: '..c); if (not CONFIG.TEST_MODE) then cmd(c); end; else install_log:append('No existing MIDI_Enc remotes found for deleting.') end local length = 0; for i = 1, math.huge do local obj = type..tostring(i); if ( not get.verify(obj) ) then break; else length = i; end; end length = length + 1 if (not CONFIG.TEST_MODE) then pi.generate(type..length, SCRIPTS.remotes); end; install_log:append('MIDI Remotes installed starting at #'..length) local m = class.MsgBox:new('PLUGIN COMPLETED SUCCESSFULLY'); m:append('See System Monitor for details.'); m:msgbox(); PLUGIN_COMPLETE = true; ::EOF:: end local function Cleanup() PLUGIN_COMPLETE = false for _, v in pairs(pBars) do v:stop() end for _, v in ipairs(cleanup_cmd) do gma.cmd(v) end for _, v in ipairs(install_log) do gma.echo(gui.tcol.cyan..v) gma.feedback(gui.tcol.cyan..v) end install_log = ST:new() pBars = ST:new() cleanup_cmd = ST:new() end --<FORMATEND>


SCRIPTS.remotes = [[
<?xml version="1.0" encoding="utf-8"?>
<MA xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.malighting.de/grandma2/xml/MA" xsi:schemaLocation="http://schemas.malighting.de/grandma2/xml/MA http://schemas.malighting.de/grandma2/xml/3.9.0/MA.xsd" major_vers="3" minor_vers="0" stream_vers="0">
    <Info datetime="2020-08-27T16:20:22" showfile="midi encoder demo start" />
    <RemoteMidi index="0" note="48" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(0, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="1" note="49" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(0, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="2" note="50" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(0, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="3" note="51" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(0, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="4" note="52" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(1, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="5" note="53" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(1, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="6" note="54" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(1, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="7" note="55" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(1, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="8" note="56" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(2, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="9" note="57" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(2, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="10" note="58" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(2, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="11" note="59" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(2, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="12" note="60" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(3, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="13" note="61" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(3, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="14" note="62" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(3, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="15" note="63" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(3, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="16" note="8" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(5, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="17" note="9" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(5, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="18" note="10" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(5, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="19" note="11" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(5, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="20" note="4" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(6, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="21" note="5" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(6, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="22" note="6" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(6, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="23" note="7" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(6, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="24" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(7, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="25" note="1" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(7, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="26" note="2" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(7, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="27" note="3" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(7, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="28" note="12" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(4, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="29" note="13" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(4, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="30" note="14" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(4, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="31" note="15" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(4, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="32" note="44" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.wheel(4)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="33" note="45" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2019-10-29T00:00:00">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.wheel(-4)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="34" note="16" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(8, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="35" note="17" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(8, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="36" note="18" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(8, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="37" note="19" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(8, false)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="38" note="20" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(9, -1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="39" note="21" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.rotate(9, 1)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="40" note="22" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(9, true)&quot;</macro_line>
    </RemoteMidi>
    <RemoteMidi index="41" note="23" channel="11" type="macro_line">
        <InfoItems>
            <Info date="2020-08-27T16:14:34">MIDI_Enc</Info>
        </InfoItems>
        <macro_line>LUA &quot;MIDI.click(9, false)&quot;</macro_line>
    </RemoteMidi>
</MA>
]]

return Main, Cleanup